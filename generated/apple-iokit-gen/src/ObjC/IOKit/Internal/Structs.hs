{-# LANGUAGE RecordWildCards #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.IOKit.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)

-- | IOColorEntry
--
-- A structure defining one entry of a color lookup table.
--
-- This structure is used by IOFramebuffer to define an entry of a color lookup table.  index Number of pixels visible per row.  red Value of red component 0-65535.  green Value of green component 0-65535.  blue Value of blue component 0-65535.
data IOColorEntry = IOColorEntry
  { ioColorEntryIndex :: !CUShort
  , ioColorEntryRed :: !CUShort
  , ioColorEntryGreen :: !CUShort
  , ioColorEntryBlue :: !CUShort
  } deriving (Eq, Show)

instance Storable IOColorEntry where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOColorEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOColorEntry {..}) = do
    pokeByteOff p 0 ioColorEntryIndex
    pokeByteOff p 2 ioColorEntryRed
    pokeByteOff p 4 ioColorEntryGreen
    pokeByteOff p 6 ioColorEntryBlue

{-# NOINLINE ioColorEntryStructType #-}
ioColorEntryStructType :: Ptr CType
ioColorEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argIOColorEntry :: IOColorEntry -> Arg
argIOColorEntry = mkStorableArg ioColorEntryStructType

retIOColorEntry :: RetType IOColorEntry
retIOColorEntry = mkStorableRetType ioColorEntryStructType

-- | / Display mode timing information
data IODetailedTimingInformationV1 = IODetailedTimingInformationV1
  { ioDetailedTimingInformationV1PixelClock :: !CUInt
  , ioDetailedTimingInformationV1HorizontalActive :: !CUInt
  , ioDetailedTimingInformationV1HorizontalBlanking :: !CUInt
  , ioDetailedTimingInformationV1HorizontalBorder :: !CUInt
  , ioDetailedTimingInformationV1HorizontalSyncOffset :: !CUInt
  , ioDetailedTimingInformationV1HorizontalSyncWidth :: !CUInt
  , ioDetailedTimingInformationV1VerticalActive :: !CUInt
  , ioDetailedTimingInformationV1VerticalBlanking :: !CUInt
  , ioDetailedTimingInformationV1VerticalBorder :: !CUInt
  , ioDetailedTimingInformationV1VerticalSyncOffset :: !CUInt
  , ioDetailedTimingInformationV1VerticalSyncWidth :: !CUInt
  } deriving (Eq, Show)

instance Storable IODetailedTimingInformationV1 where
  sizeOf    _ = 44
  alignment _ = 4
  peek p = IODetailedTimingInformationV1 <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
  poke p (IODetailedTimingInformationV1 {..}) = do
    pokeByteOff p 0 ioDetailedTimingInformationV1PixelClock
    pokeByteOff p 4 ioDetailedTimingInformationV1HorizontalActive
    pokeByteOff p 8 ioDetailedTimingInformationV1HorizontalBlanking
    pokeByteOff p 12 ioDetailedTimingInformationV1HorizontalBorder
    pokeByteOff p 16 ioDetailedTimingInformationV1HorizontalSyncOffset
    pokeByteOff p 20 ioDetailedTimingInformationV1HorizontalSyncWidth
    pokeByteOff p 24 ioDetailedTimingInformationV1VerticalActive
    pokeByteOff p 28 ioDetailedTimingInformationV1VerticalBlanking
    pokeByteOff p 32 ioDetailedTimingInformationV1VerticalBorder
    pokeByteOff p 36 ioDetailedTimingInformationV1VerticalSyncOffset
    pokeByteOff p 40 ioDetailedTimingInformationV1VerticalSyncWidth

{-# NOINLINE ioDetailedTimingInformationV1StructType #-}
ioDetailedTimingInformationV1StructType :: Ptr CType
ioDetailedTimingInformationV1StructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argIODetailedTimingInformationV1 :: IODetailedTimingInformationV1 -> Arg
argIODetailedTimingInformationV1 = mkStorableArg ioDetailedTimingInformationV1StructType

retIODetailedTimingInformationV1 :: RetType IODetailedTimingInformationV1
retIODetailedTimingInformationV1 = mkStorableRetType ioDetailedTimingInformationV1StructType

data IOFBDisplayModeDescription = IOFBDisplayModeDescription
  { iofbDisplayModeDescriptionInfo :: !(Ptr ())
  , iofbDisplayModeDescriptionTimingInfo :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable IOFBDisplayModeDescription where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = IOFBDisplayModeDescription <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (IOFBDisplayModeDescription {..}) = do
    pokeByteOff p 0 iofbDisplayModeDescriptionInfo
    pokeByteOff p 8 iofbDisplayModeDescriptionTimingInfo

{-# NOINLINE iofbDisplayModeDescriptionStructType #-}
iofbDisplayModeDescriptionStructType :: Ptr CType
iofbDisplayModeDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argIOFBDisplayModeDescription :: IOFBDisplayModeDescription -> Arg
argIOFBDisplayModeDescription = mkStorableArg iofbDisplayModeDescriptionStructType

retIOFBDisplayModeDescription :: RetType IOFBDisplayModeDescription
retIOFBDisplayModeDescription = mkStorableRetType iofbDisplayModeDescriptionStructType

data IOFixedPoint32 = IOFixedPoint32
  { ioFixedPoint32X :: !CInt
  , ioFixedPoint32Y :: !CInt
  } deriving (Eq, Show)

instance Storable IOFixedPoint32 where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = IOFixedPoint32 <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (IOFixedPoint32 {..}) = do
    pokeByteOff p 0 ioFixedPoint32X
    pokeByteOff p 4 ioFixedPoint32Y

{-# NOINLINE ioFixedPoint32StructType #-}
ioFixedPoint32StructType :: Ptr CType
ioFixedPoint32StructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint]

argIOFixedPoint32 :: IOFixedPoint32 -> Arg
argIOFixedPoint32 = mkStorableArg ioFixedPoint32StructType

retIOFixedPoint32 :: RetType IOFixedPoint32
retIOFixedPoint32 = mkStorableRetType ioFixedPoint32StructType

data IOGBounds = IOGBounds
  { iogBoundsMinx :: !CShort
  , iogBoundsMaxx :: !CShort
  , iogBoundsMiny :: !CShort
  , iogBoundsMaxy :: !CShort
  } deriving (Eq, Show)

instance Storable IOGBounds where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOGBounds <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOGBounds {..}) = do
    pokeByteOff p 0 iogBoundsMinx
    pokeByteOff p 2 iogBoundsMaxx
    pokeByteOff p 4 iogBoundsMiny
    pokeByteOff p 6 iogBoundsMaxy

{-# NOINLINE iogBoundsStructType #-}
iogBoundsStructType :: Ptr CType
iogBoundsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argIOGBounds :: IOGBounds -> Arg
argIOGBounds = mkStorableArg iogBoundsStructType

retIOGBounds :: RetType IOGBounds
retIOGBounds = mkStorableRetType iogBoundsStructType

data IOGPoint = IOGPoint
  { iogPointX :: !CShort
  , iogPointY :: !CShort
  } deriving (Eq, Show)

instance Storable IOGPoint where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOGPoint <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (IOGPoint {..}) = do
    pokeByteOff p 0 iogPointX
    pokeByteOff p 2 iogPointY

{-# NOINLINE iogPointStructType #-}
iogPointStructType :: Ptr CType
iogPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argIOGPoint :: IOGPoint -> Arg
argIOGPoint = mkStorableArg iogPointStructType

retIOGPoint :: RetType IOGPoint
retIOGPoint = mkStorableRetType iogPointStructType

data IOGSize = IOGSize
  { iogSizeWidth :: !CShort
  , iogSizeHeight :: !CShort
  } deriving (Eq, Show)

instance Storable IOGSize where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOGSize <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (IOGSize {..}) = do
    pokeByteOff p 0 iogSizeWidth
    pokeByteOff p 2 iogSizeHeight

{-# NOINLINE iogSizeStructType #-}
iogSizeStructType :: Ptr CType
iogSizeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argIOGSize :: IOGSize -> Arg
argIOGSize = mkStorableArg iogSizeStructType

retIOGSize :: RetType IOGSize
retIOGSize = mkStorableRetType iogSizeStructType

-- | IOHIDCompletion
--
-- Struct specifying action to perform when set/get report completes.
--
-- target
--
-- The target to pass to the action function.
--
-- action
--
-- The function to call.
--
-- parameter
--
-- The parameter to pass to the action function.
data IOHIDCompletion = IOHIDCompletion
  { iohidCompletionTarget :: !(Ptr ())
  , iohidCompletionAction :: !(Ptr ())
  , iohidCompletionParameter :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable IOHIDCompletion where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = IOHIDCompletion <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (IOHIDCompletion {..}) = do
    pokeByteOff p 0 iohidCompletionTarget
    pokeByteOff p 8 iohidCompletionAction
    pokeByteOff p 16 iohidCompletionParameter

{-# NOINLINE iohidCompletionStructType #-}
iohidCompletionStructType :: Ptr CType
iohidCompletionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argIOHIDCompletion :: IOHIDCompletion -> Arg
argIOHIDCompletion = mkStorableArg iohidCompletionStructType

retIOHIDCompletion :: RetType IOHIDCompletion
retIOHIDCompletion = mkStorableRetType iohidCompletionStructType

-- | IOUSBBOSDescriptor
--
-- USB BOS descriptor. See the USB Specification at             http://www.usb.org.             USB 3.0 9.6.2: Binary Device Object Store (BOS)
data IOUSBBOSDescriptor = IOUSBBOSDescriptor
  { iousbbosDescriptorBLength :: !CUChar
  , iousbbosDescriptorBDescriptorType :: !CUChar
  , iousbbosDescriptorWTotalLength :: !CUShort
  , iousbbosDescriptorBNumDeviceCaps :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBBOSDescriptor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBBOSDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBBOSDescriptor {..}) = do
    pokeByteOff p 0 iousbbosDescriptorBLength
    pokeByteOff p 1 iousbbosDescriptorBDescriptorType
    pokeByteOff p 2 iousbbosDescriptorWTotalLength
    pokeByteOff p 4 iousbbosDescriptorBNumDeviceCaps

{-# NOINLINE iousbbosDescriptorStructType #-}
iousbbosDescriptorStructType :: Ptr CType
iousbbosDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8]

argIOUSBBOSDescriptor :: IOUSBBOSDescriptor -> Arg
argIOUSBBOSDescriptor = mkStorableArg iousbbosDescriptorStructType

retIOUSBBOSDescriptor :: RetType IOUSBBOSDescriptor
retIOUSBBOSDescriptor = mkStorableRetType iousbbosDescriptorStructType

-- | IOUSBConfigurationDescHeader
--
-- Header of a IOUSBConfigurationDescriptor.  Used to get the total length of the descriptor.             USB 2.0 9.6.3: Configuration
data IOUSBConfigurationDescHeader = IOUSBConfigurationDescHeader
  { iousbConfigurationDescHeaderBLength :: !CUChar
  , iousbConfigurationDescHeaderBDescriptorType :: !CUChar
  , iousbConfigurationDescHeaderWTotalLength :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBConfigurationDescHeader where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOUSBConfigurationDescHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (IOUSBConfigurationDescHeader {..}) = do
    pokeByteOff p 0 iousbConfigurationDescHeaderBLength
    pokeByteOff p 1 iousbConfigurationDescHeaderBDescriptorType
    pokeByteOff p 2 iousbConfigurationDescHeaderWTotalLength

{-# NOINLINE iousbConfigurationDescHeaderStructType #-}
iousbConfigurationDescHeaderStructType :: Ptr CType
iousbConfigurationDescHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBConfigurationDescHeader :: IOUSBConfigurationDescHeader -> Arg
argIOUSBConfigurationDescHeader = mkStorableArg iousbConfigurationDescHeaderStructType

retIOUSBConfigurationDescHeader :: RetType IOUSBConfigurationDescHeader
retIOUSBConfigurationDescHeader = mkStorableRetType iousbConfigurationDescHeaderStructType

-- | IOUSBConfigurationDescriptor
--
-- Standard USB Configuration Descriptor.  It is variable length, so this only specifies             the known fields.  We use the wTotalLength field to read the whole descriptor.             See the USB Specification at http://www.usb.org.             USB 2.0 9.6.3: Configuration
data IOUSBConfigurationDescriptor = IOUSBConfigurationDescriptor
  { iousbConfigurationDescriptorBLength :: !CUChar
  , iousbConfigurationDescriptorBDescriptorType :: !CUChar
  , iousbConfigurationDescriptorWTotalLength :: !CUShort
  , iousbConfigurationDescriptorBNumInterfaces :: !CUChar
  , iousbConfigurationDescriptorBConfigurationValue :: !CUChar
  , iousbConfigurationDescriptorIConfiguration :: !CUChar
  , iousbConfigurationDescriptorBmAttributes :: !CUChar
  , iousbConfigurationDescriptorMaxPower :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBConfigurationDescriptor where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBConfigurationDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBConfigurationDescriptor {..}) = do
    pokeByteOff p 0 iousbConfigurationDescriptorBLength
    pokeByteOff p 1 iousbConfigurationDescriptorBDescriptorType
    pokeByteOff p 2 iousbConfigurationDescriptorWTotalLength
    pokeByteOff p 4 iousbConfigurationDescriptorBNumInterfaces
    pokeByteOff p 5 iousbConfigurationDescriptorBConfigurationValue
    pokeByteOff p 6 iousbConfigurationDescriptorIConfiguration
    pokeByteOff p 7 iousbConfigurationDescriptorBmAttributes
    pokeByteOff p 8 iousbConfigurationDescriptorMaxPower

{-# NOINLINE iousbConfigurationDescriptorStructType #-}
iousbConfigurationDescriptorStructType :: Ptr CType
iousbConfigurationDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBConfigurationDescriptor :: IOUSBConfigurationDescriptor -> Arg
argIOUSBConfigurationDescriptor = mkStorableArg iousbConfigurationDescriptorStructType

retIOUSBConfigurationDescriptor :: RetType IOUSBConfigurationDescriptor
retIOUSBConfigurationDescriptor = mkStorableRetType iousbConfigurationDescriptorStructType

-- | IOUSBDFUDescriptor
--
-- USB Device Firmware Update Descriptor. See the USB Device Firmware Update             Specification at http://www.usb.org.
data IOUSBDFUDescriptor = IOUSBDFUDescriptor
  { iousbdfuDescriptorBLength :: !CUChar
  , iousbdfuDescriptorBDescriptorType :: !CUChar
  , iousbdfuDescriptorBmAttributes :: !CUChar
  , iousbdfuDescriptorWDetachTimeout :: !CUShort
  , iousbdfuDescriptorWTransferSize :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDFUDescriptor where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOUSBDFUDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOUSBDFUDescriptor {..}) = do
    pokeByteOff p 0 iousbdfuDescriptorBLength
    pokeByteOff p 1 iousbdfuDescriptorBDescriptorType
    pokeByteOff p 2 iousbdfuDescriptorBmAttributes
    pokeByteOff p 4 iousbdfuDescriptorWDetachTimeout
    pokeByteOff p 6 iousbdfuDescriptorWTransferSize

{-# NOINLINE iousbdfuDescriptorStructType #-}
iousbdfuDescriptorStructType :: Ptr CType
iousbdfuDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argIOUSBDFUDescriptor :: IOUSBDFUDescriptor -> Arg
argIOUSBDFUDescriptor = mkStorableArg iousbdfuDescriptorStructType

retIOUSBDFUDescriptor :: RetType IOUSBDFUDescriptor
retIOUSBDFUDescriptor = mkStorableRetType iousbdfuDescriptorStructType

-- | IOUSBDescriptorHeader
--
-- Base descriptor defined by USB 2.0 9.5
--
-- IOUSBDescriptorDefinitions declares structs to represent a variety of USB standard              descriptors.
data IOUSBDescriptor = IOUSBDescriptor
  { iousbDescriptorBLength :: !CUChar
  , iousbDescriptorBDescriptorType :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDescriptor where
  sizeOf    _ = 2
  alignment _ = 1
  peek p = IOUSBDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
  poke p (IOUSBDescriptor {..}) = do
    pokeByteOff p 0 iousbDescriptorBLength
    pokeByteOff p 1 iousbDescriptorBDescriptorType

{-# NOINLINE iousbDescriptorStructType #-}
iousbDescriptorStructType :: Ptr CType
iousbDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8]

argIOUSBDescriptor :: IOUSBDescriptor -> Arg
argIOUSBDescriptor = mkStorableArg iousbDescriptorStructType

retIOUSBDescriptor :: RetType IOUSBDescriptor
retIOUSBDescriptor = mkStorableRetType iousbDescriptorStructType

-- | IOUSBDescriptorHeader
--
-- Base descriptor defined by USB 2.0 9.5
--
-- IOUSBDescriptorDefinitions declares structs to represent a variety of USB standard              descriptors.
data IOUSBDescriptorHeader = IOUSBDescriptorHeader
  { iousbDescriptorHeaderBLength :: !CUChar
  , iousbDescriptorHeaderBDescriptorType :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDescriptorHeader where
  sizeOf    _ = 2
  alignment _ = 1
  peek p = IOUSBDescriptorHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
  poke p (IOUSBDescriptorHeader {..}) = do
    pokeByteOff p 0 iousbDescriptorHeaderBLength
    pokeByteOff p 1 iousbDescriptorHeaderBDescriptorType

{-# NOINLINE iousbDescriptorHeaderStructType #-}
iousbDescriptorHeaderStructType :: Ptr CType
iousbDescriptorHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8]

argIOUSBDescriptorHeader :: IOUSBDescriptorHeader -> Arg
argIOUSBDescriptorHeader = mkStorableArg iousbDescriptorHeaderStructType

retIOUSBDescriptorHeader :: RetType IOUSBDescriptorHeader
retIOUSBDescriptorHeader = mkStorableRetType iousbDescriptorHeaderStructType

-- | IOUSBDeviceCapabilityBillboardAltConfig
--
-- Device Capability Billboard Alternate Setting Info.             USB Billboard 3.1.6.2: Billboard Capability Descriptor V1.1 and 1.21+
data IOUSBDeviceCapabilityBillboardAltConfig = IOUSBDeviceCapabilityBillboardAltConfig
  { iousbDeviceCapabilityBillboardAltConfigWSVID :: !CUShort
  , iousbDeviceCapabilityBillboardAltConfigBAltenateMode :: !CUChar
  , iousbDeviceCapabilityBillboardAltConfigIAlternateModeString :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityBillboardAltConfig where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOUSBDeviceCapabilityBillboardAltConfig <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (IOUSBDeviceCapabilityBillboardAltConfig {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityBillboardAltConfigWSVID
    pokeByteOff p 2 iousbDeviceCapabilityBillboardAltConfigBAltenateMode
    pokeByteOff p 3 iousbDeviceCapabilityBillboardAltConfigIAlternateModeString

{-# NOINLINE iousbDeviceCapabilityBillboardAltConfigStructType #-}
iousbDeviceCapabilityBillboardAltConfigStructType :: Ptr CType
iousbDeviceCapabilityBillboardAltConfigStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceCapabilityBillboardAltConfig :: IOUSBDeviceCapabilityBillboardAltConfig -> Arg
argIOUSBDeviceCapabilityBillboardAltConfig = mkStorableArg iousbDeviceCapabilityBillboardAltConfigStructType

retIOUSBDeviceCapabilityBillboardAltConfig :: RetType IOUSBDeviceCapabilityBillboardAltConfig
retIOUSBDeviceCapabilityBillboardAltConfig = mkStorableRetType iousbDeviceCapabilityBillboardAltConfigStructType

-- | IOUSBDeviceCapabilityBillboardAltConfig
--
-- Device Capability Billboard Alternate Setting Info.             USB Billboard 3.1.6.2: Billboard Capability Descriptor V1.2
data IOUSBDeviceCapabilityBillboardAltConfigCompatibility = IOUSBDeviceCapabilityBillboardAltConfigCompatibility
  { iousbDeviceCapabilityBillboardAltConfigCompatibilityWSVID :: !CUShort
  , iousbDeviceCapabilityBillboardAltConfigCompatibilityDwAlternateMode :: !CUInt
  , iousbDeviceCapabilityBillboardAltConfigCompatibilityIAlternateModeString :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityBillboardAltConfigCompatibility where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = IOUSBDeviceCapabilityBillboardAltConfigCompatibility <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (IOUSBDeviceCapabilityBillboardAltConfigCompatibility {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityBillboardAltConfigCompatibilityWSVID
    pokeByteOff p 4 iousbDeviceCapabilityBillboardAltConfigCompatibilityDwAlternateMode
    pokeByteOff p 8 iousbDeviceCapabilityBillboardAltConfigCompatibilityIAlternateModeString

{-# NOINLINE iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType #-}
iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType :: Ptr CType
iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_uint8]

argIOUSBDeviceCapabilityBillboardAltConfigCompatibility :: IOUSBDeviceCapabilityBillboardAltConfigCompatibility -> Arg
argIOUSBDeviceCapabilityBillboardAltConfigCompatibility = mkStorableArg iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType

retIOUSBDeviceCapabilityBillboardAltConfigCompatibility :: RetType IOUSBDeviceCapabilityBillboardAltConfigCompatibility
retIOUSBDeviceCapabilityBillboardAltConfigCompatibility = mkStorableRetType iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType

-- | IOUSBDeviceCapabilityBillboardAltMode
--
-- Device Capability Billboard Alternate mode.             USB Billboard 3.1.6.3: Billboard Capability Descriptor V1.21
data IOUSBDeviceCapabilityBillboardAltMode = IOUSBDeviceCapabilityBillboardAltMode
  { iousbDeviceCapabilityBillboardAltModeBLength :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeBDescriptorType :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeBDevCapabilityType :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeBIndex :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeDwAlternateModeVdo :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityBillboardAltMode where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBDeviceCapabilityBillboardAltMode <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (IOUSBDeviceCapabilityBillboardAltMode {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityBillboardAltModeBLength
    pokeByteOff p 1 iousbDeviceCapabilityBillboardAltModeBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilityBillboardAltModeBDevCapabilityType
    pokeByteOff p 3 iousbDeviceCapabilityBillboardAltModeBIndex
    pokeByteOff p 4 iousbDeviceCapabilityBillboardAltModeDwAlternateModeVdo

{-# NOINLINE iousbDeviceCapabilityBillboardAltModeStructType #-}
iousbDeviceCapabilityBillboardAltModeStructType :: Ptr CType
iousbDeviceCapabilityBillboardAltModeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBDeviceCapabilityBillboardAltMode :: IOUSBDeviceCapabilityBillboardAltMode -> Arg
argIOUSBDeviceCapabilityBillboardAltMode = mkStorableArg iousbDeviceCapabilityBillboardAltModeStructType

retIOUSBDeviceCapabilityBillboardAltMode :: RetType IOUSBDeviceCapabilityBillboardAltMode
retIOUSBDeviceCapabilityBillboardAltMode = mkStorableRetType iousbDeviceCapabilityBillboardAltModeStructType

-- | IOUSBDeviceCapabilityDescriptorHeader
--
-- Device Capability descriptor.  See the USB Specification at             http://www.usb.org.             USB 3.0 9.6.2: Binary Device Object Store (BOS)
data IOUSBDeviceCapabilityDescriptorHeader = IOUSBDeviceCapabilityDescriptorHeader
  { iousbDeviceCapabilityDescriptorHeaderBLength :: !CUChar
  , iousbDeviceCapabilityDescriptorHeaderBDescriptorType :: !CUChar
  , iousbDeviceCapabilityDescriptorHeaderBDevCapabilityType :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityDescriptorHeader where
  sizeOf    _ = 3
  alignment _ = 1
  peek p = IOUSBDeviceCapabilityDescriptorHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (IOUSBDeviceCapabilityDescriptorHeader {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityDescriptorHeaderBLength
    pokeByteOff p 1 iousbDeviceCapabilityDescriptorHeaderBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilityDescriptorHeaderBDevCapabilityType

{-# NOINLINE iousbDeviceCapabilityDescriptorHeaderStructType #-}
iousbDeviceCapabilityDescriptorHeaderStructType :: Ptr CType
iousbDeviceCapabilityDescriptorHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceCapabilityDescriptorHeader :: IOUSBDeviceCapabilityDescriptorHeader -> Arg
argIOUSBDeviceCapabilityDescriptorHeader = mkStorableArg iousbDeviceCapabilityDescriptorHeaderStructType

retIOUSBDeviceCapabilityDescriptorHeader :: RetType IOUSBDeviceCapabilityDescriptorHeader
retIOUSBDeviceCapabilityDescriptorHeader = mkStorableRetType iousbDeviceCapabilityDescriptorHeaderStructType

-- | IOUSBDeviceCapabilitySuperSpeedUSB
--
-- Device Capability SuperSpeed USB. USB 3.0 9.6.2.2: SuperSpeed USB Device Capability
data IOUSBDeviceCapabilitySuperSpeedUSB = IOUSBDeviceCapabilitySuperSpeedUSB
  { iousbDeviceCapabilitySuperSpeedUSBBLength :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBDescriptorType :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBDevCapabilityType :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBmAttributes :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBWSpeedsSupported :: !CUShort
  , iousbDeviceCapabilitySuperSpeedUSBBFunctionalitySupport :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBU1DevExitLat :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBWU2DevExitLat :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilitySuperSpeedUSB where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBDeviceCapabilitySuperSpeedUSB <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBDeviceCapabilitySuperSpeedUSB {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilitySuperSpeedUSBBLength
    pokeByteOff p 1 iousbDeviceCapabilitySuperSpeedUSBBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilitySuperSpeedUSBBDevCapabilityType
    pokeByteOff p 3 iousbDeviceCapabilitySuperSpeedUSBBmAttributes
    pokeByteOff p 4 iousbDeviceCapabilitySuperSpeedUSBWSpeedsSupported
    pokeByteOff p 6 iousbDeviceCapabilitySuperSpeedUSBBFunctionalitySupport
    pokeByteOff p 7 iousbDeviceCapabilitySuperSpeedUSBBU1DevExitLat
    pokeByteOff p 8 iousbDeviceCapabilitySuperSpeedUSBWU2DevExitLat

{-# NOINLINE iousbDeviceCapabilitySuperSpeedUSBStructType #-}
iousbDeviceCapabilitySuperSpeedUSBStructType :: Ptr CType
iousbDeviceCapabilitySuperSpeedUSBStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBDeviceCapabilitySuperSpeedUSB :: IOUSBDeviceCapabilitySuperSpeedUSB -> Arg
argIOUSBDeviceCapabilitySuperSpeedUSB = mkStorableArg iousbDeviceCapabilitySuperSpeedUSBStructType

retIOUSBDeviceCapabilitySuperSpeedUSB :: RetType IOUSBDeviceCapabilitySuperSpeedUSB
retIOUSBDeviceCapabilitySuperSpeedUSB = mkStorableRetType iousbDeviceCapabilitySuperSpeedUSBStructType

-- | IOUSBDeviceCapabilityUSB2Extension
--
-- Device Capability USB 2.0 Extension.             USB 3.0 9.6.2.1: USB 2.0 Extension
data IOUSBDeviceCapabilityUSB2Extension = IOUSBDeviceCapabilityUSB2Extension
  { iousbDeviceCapabilityUSB2ExtensionBLength :: !CUChar
  , iousbDeviceCapabilityUSB2ExtensionBDescriptorType :: !CUChar
  , iousbDeviceCapabilityUSB2ExtensionBDevCapabilityType :: !CUChar
  , iousbDeviceCapabilityUSB2ExtensionBmAttributes :: !CUInt
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityUSB2Extension where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = IOUSBDeviceCapabilityUSB2Extension <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBDeviceCapabilityUSB2Extension {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityUSB2ExtensionBLength
    pokeByteOff p 1 iousbDeviceCapabilityUSB2ExtensionBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilityUSB2ExtensionBDevCapabilityType
    pokeByteOff p 4 iousbDeviceCapabilityUSB2ExtensionBmAttributes

{-# NOINLINE iousbDeviceCapabilityUSB2ExtensionStructType #-}
iousbDeviceCapabilityUSB2ExtensionStructType :: Ptr CType
iousbDeviceCapabilityUSB2ExtensionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint]

argIOUSBDeviceCapabilityUSB2Extension :: IOUSBDeviceCapabilityUSB2Extension -> Arg
argIOUSBDeviceCapabilityUSB2Extension = mkStorableArg iousbDeviceCapabilityUSB2ExtensionStructType

retIOUSBDeviceCapabilityUSB2Extension :: RetType IOUSBDeviceCapabilityUSB2Extension
retIOUSBDeviceCapabilityUSB2Extension = mkStorableRetType iousbDeviceCapabilityUSB2ExtensionStructType

-- | IOUSBDeviceDescriptor
--
-- Descriptor for a USB Device.             See the USB Specification at http://www.usb.org.
data IOUSBDeviceDescriptor = IOUSBDeviceDescriptor
  { iousbDeviceDescriptorBLength :: !CUChar
  , iousbDeviceDescriptorBDescriptorType :: !CUChar
  , iousbDeviceDescriptorBcdUSB :: !CUShort
  , iousbDeviceDescriptorBDeviceClass :: !CUChar
  , iousbDeviceDescriptorBDeviceSubClass :: !CUChar
  , iousbDeviceDescriptorBDeviceProtocol :: !CUChar
  , iousbDeviceDescriptorBMaxPacketSize0 :: !CUChar
  , iousbDeviceDescriptorIdVendor :: !CUShort
  , iousbDeviceDescriptorIdProduct :: !CUShort
  , iousbDeviceDescriptorBcdDevice :: !CUShort
  , iousbDeviceDescriptorIManufacturer :: !CUChar
  , iousbDeviceDescriptorIProduct :: !CUChar
  , iousbDeviceDescriptorISerialNumber :: !CUChar
  , iousbDeviceDescriptorBNumConfigurations :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceDescriptor where
  sizeOf    _ = 18
  alignment _ = 2
  peek p = IOUSBDeviceDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 15
    <*> peekByteOff p 16
    <*> peekByteOff p 17
  poke p (IOUSBDeviceDescriptor {..}) = do
    pokeByteOff p 0 iousbDeviceDescriptorBLength
    pokeByteOff p 1 iousbDeviceDescriptorBDescriptorType
    pokeByteOff p 2 iousbDeviceDescriptorBcdUSB
    pokeByteOff p 4 iousbDeviceDescriptorBDeviceClass
    pokeByteOff p 5 iousbDeviceDescriptorBDeviceSubClass
    pokeByteOff p 6 iousbDeviceDescriptorBDeviceProtocol
    pokeByteOff p 7 iousbDeviceDescriptorBMaxPacketSize0
    pokeByteOff p 8 iousbDeviceDescriptorIdVendor
    pokeByteOff p 10 iousbDeviceDescriptorIdProduct
    pokeByteOff p 12 iousbDeviceDescriptorBcdDevice
    pokeByteOff p 14 iousbDeviceDescriptorIManufacturer
    pokeByteOff p 15 iousbDeviceDescriptorIProduct
    pokeByteOff p 16 iousbDeviceDescriptorISerialNumber
    pokeByteOff p 17 iousbDeviceDescriptorBNumConfigurations

{-# NOINLINE iousbDeviceDescriptorStructType #-}
iousbDeviceDescriptorStructType :: Ptr CType
iousbDeviceDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceDescriptor :: IOUSBDeviceDescriptor -> Arg
argIOUSBDeviceDescriptor = mkStorableArg iousbDeviceDescriptorStructType

retIOUSBDeviceDescriptor :: RetType IOUSBDeviceDescriptor
retIOUSBDeviceDescriptor = mkStorableRetType iousbDeviceDescriptorStructType

-- | IOUSBDeviceQualifierDescriptor
--
-- USB Device Qualifier Descriptor.             See the USB Specification at http://www.usb.org.             USB 2.0 9.6.2: Device Qualifier
data IOUSBDeviceQualifierDescriptor = IOUSBDeviceQualifierDescriptor
  { iousbDeviceQualifierDescriptorBLength :: !CUChar
  , iousbDeviceQualifierDescriptorBDescriptorType :: !CUChar
  , iousbDeviceQualifierDescriptorBcdUSB :: !CUShort
  , iousbDeviceQualifierDescriptorBDeviceClass :: !CUChar
  , iousbDeviceQualifierDescriptorBDeviceSubClass :: !CUChar
  , iousbDeviceQualifierDescriptorBDeviceProtocol :: !CUChar
  , iousbDeviceQualifierDescriptorBMaxPacketSize0 :: !CUChar
  , iousbDeviceQualifierDescriptorBNumConfigurations :: !CUChar
  , iousbDeviceQualifierDescriptorBReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceQualifierDescriptor where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBDeviceQualifierDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 9
  poke p (IOUSBDeviceQualifierDescriptor {..}) = do
    pokeByteOff p 0 iousbDeviceQualifierDescriptorBLength
    pokeByteOff p 1 iousbDeviceQualifierDescriptorBDescriptorType
    pokeByteOff p 2 iousbDeviceQualifierDescriptorBcdUSB
    pokeByteOff p 4 iousbDeviceQualifierDescriptorBDeviceClass
    pokeByteOff p 5 iousbDeviceQualifierDescriptorBDeviceSubClass
    pokeByteOff p 6 iousbDeviceQualifierDescriptorBDeviceProtocol
    pokeByteOff p 7 iousbDeviceQualifierDescriptorBMaxPacketSize0
    pokeByteOff p 8 iousbDeviceQualifierDescriptorBNumConfigurations
    pokeByteOff p 9 iousbDeviceQualifierDescriptorBReserved

{-# NOINLINE iousbDeviceQualifierDescriptorStructType #-}
iousbDeviceQualifierDescriptorStructType :: Ptr CType
iousbDeviceQualifierDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceQualifierDescriptor :: IOUSBDeviceQualifierDescriptor -> Arg
argIOUSBDeviceQualifierDescriptor = mkStorableArg iousbDeviceQualifierDescriptorStructType

retIOUSBDeviceQualifierDescriptor :: RetType IOUSBDeviceQualifierDescriptor
retIOUSBDeviceQualifierDescriptor = mkStorableRetType iousbDeviceQualifierDescriptorStructType

-- | IOUSBDeviceRequest
--
-- Standard device request.             See the USB Specification at http://www.usb.org.             USB 2.0 9.3: USB Device Requests
data IOUSBDeviceRequest = IOUSBDeviceRequest
  { iousbDeviceRequestBmRequestType :: !CUChar
  , iousbDeviceRequestBRequest :: !CUChar
  , iousbDeviceRequestWValue :: !CUShort
  , iousbDeviceRequestWIndex :: !CUShort
  , iousbDeviceRequestWLength :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceRequest where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOUSBDeviceRequest <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOUSBDeviceRequest {..}) = do
    pokeByteOff p 0 iousbDeviceRequestBmRequestType
    pokeByteOff p 1 iousbDeviceRequestBRequest
    pokeByteOff p 2 iousbDeviceRequestWValue
    pokeByteOff p 4 iousbDeviceRequestWIndex
    pokeByteOff p 6 iousbDeviceRequestWLength

{-# NOINLINE iousbDeviceRequestStructType #-}
iousbDeviceRequestStructType :: Ptr CType
iousbDeviceRequestStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argIOUSBDeviceRequest :: IOUSBDeviceRequest -> Arg
argIOUSBDeviceRequest = mkStorableArg iousbDeviceRequestStructType

retIOUSBDeviceRequest :: RetType IOUSBDeviceRequest
retIOUSBDeviceRequest = mkStorableRetType iousbDeviceRequestStructType

-- | IOUSBDeviceRequestSetSELData
--
-- See the USB Specification at http://www.usb.org.             USB 3.0 9.4.12: Set SEL Standard Device Request
data IOUSBDeviceRequestSetSELData = IOUSBDeviceRequestSetSELData
  { iousbDeviceRequestSetSELDataU1Sel :: !CUChar
  , iousbDeviceRequestSetSELDataU1Pel :: !CUChar
  , iousbDeviceRequestSetSELDataU2Sel :: !CUShort
  , iousbDeviceRequestSetSELDataU2Pel :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceRequestSetSELData where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBDeviceRequestSetSELData <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBDeviceRequestSetSELData {..}) = do
    pokeByteOff p 0 iousbDeviceRequestSetSELDataU1Sel
    pokeByteOff p 1 iousbDeviceRequestSetSELDataU1Pel
    pokeByteOff p 2 iousbDeviceRequestSetSELDataU2Sel
    pokeByteOff p 4 iousbDeviceRequestSetSELDataU2Pel

{-# NOINLINE iousbDeviceRequestSetSELDataStructType #-}
iousbDeviceRequestSetSELDataStructType :: Ptr CType
iousbDeviceRequestSetSELDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argIOUSBDeviceRequestSetSELData :: IOUSBDeviceRequestSetSELData -> Arg
argIOUSBDeviceRequestSetSELData = mkStorableArg iousbDeviceRequestSetSELDataStructType

retIOUSBDeviceRequestSetSELData :: RetType IOUSBDeviceRequestSetSELData
retIOUSBDeviceRequestSetSELData = mkStorableRetType iousbDeviceRequestSetSELDataStructType

-- | IOUSBEndpointDescriptor
--
-- Descriptor for a USB Endpoint.  See the USB Specification at             http://www.usb.org.             USB 2.0 9.6.6: Endpoint
data IOUSBEndpointDescriptor = IOUSBEndpointDescriptor
  { iousbEndpointDescriptorBLength :: !CUChar
  , iousbEndpointDescriptorBDescriptorType :: !CUChar
  , iousbEndpointDescriptorBEndpointAddress :: !CUChar
  , iousbEndpointDescriptorBmAttributes :: !CUChar
  , iousbEndpointDescriptorWMaxPacketSize :: !CUShort
  , iousbEndpointDescriptorBInterval :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBEndpointDescriptor where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOUSBEndpointDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOUSBEndpointDescriptor {..}) = do
    pokeByteOff p 0 iousbEndpointDescriptorBLength
    pokeByteOff p 1 iousbEndpointDescriptorBDescriptorType
    pokeByteOff p 2 iousbEndpointDescriptorBEndpointAddress
    pokeByteOff p 3 iousbEndpointDescriptorBmAttributes
    pokeByteOff p 4 iousbEndpointDescriptorWMaxPacketSize
    pokeByteOff p 6 iousbEndpointDescriptorBInterval

{-# NOINLINE iousbEndpointDescriptorStructType #-}
iousbEndpointDescriptorStructType :: Ptr CType
iousbEndpointDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8]

argIOUSBEndpointDescriptor :: IOUSBEndpointDescriptor -> Arg
argIOUSBEndpointDescriptor = mkStorableArg iousbEndpointDescriptorStructType

retIOUSBEndpointDescriptor :: RetType IOUSBEndpointDescriptor
retIOUSBEndpointDescriptor = mkStorableRetType iousbEndpointDescriptorStructType

-- | IOUSBHIDDescriptor
--
-- USB HID Descriptor.  See the USB HID Specification at             http://www.usb.org.
data IOUSBHIDDescriptor = IOUSBHIDDescriptor
  { iousbhidDescriptorDescLen :: !CUChar
  , iousbhidDescriptorDescType :: !CUChar
  , iousbhidDescriptorDescVersNum :: !CUShort
  , iousbhidDescriptorHidCountryCode :: !CUChar
  , iousbhidDescriptorHidNumDescriptors :: !CUChar
  , iousbhidDescriptorHidDescriptorType :: !CUChar
  , iousbhidDescriptorHidDescriptorLengthLo :: !CUChar
  , iousbhidDescriptorHidDescriptorLengthHi :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBHIDDescriptor where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBHIDDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBHIDDescriptor {..}) = do
    pokeByteOff p 0 iousbhidDescriptorDescLen
    pokeByteOff p 1 iousbhidDescriptorDescType
    pokeByteOff p 2 iousbhidDescriptorDescVersNum
    pokeByteOff p 4 iousbhidDescriptorHidCountryCode
    pokeByteOff p 5 iousbhidDescriptorHidNumDescriptors
    pokeByteOff p 6 iousbhidDescriptorHidDescriptorType
    pokeByteOff p 7 iousbhidDescriptorHidDescriptorLengthLo
    pokeByteOff p 8 iousbhidDescriptorHidDescriptorLengthHi

{-# NOINLINE iousbhidDescriptorStructType #-}
iousbhidDescriptorStructType :: Ptr CType
iousbhidDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBHIDDescriptor :: IOUSBHIDDescriptor -> Arg
argIOUSBHIDDescriptor = mkStorableArg iousbhidDescriptorStructType

retIOUSBHIDDescriptor :: RetType IOUSBHIDDescriptor
retIOUSBHIDDescriptor = mkStorableRetType iousbhidDescriptorStructType

-- | IOUSBHIDReportDesc
--
-- USB HID Report Descriptor header.  See the USB HID Specification at             http://www.usb.org.
data IOUSBHIDReportDesc = IOUSBHIDReportDesc
  { iousbhidReportDescHidDescriptorType :: !CUChar
  , iousbhidReportDescHidDescriptorLengthLo :: !CUChar
  , iousbhidReportDescHidDescriptorLengthHi :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBHIDReportDesc where
  sizeOf    _ = 3
  alignment _ = 1
  peek p = IOUSBHIDReportDesc <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (IOUSBHIDReportDesc {..}) = do
    pokeByteOff p 0 iousbhidReportDescHidDescriptorType
    pokeByteOff p 1 iousbhidReportDescHidDescriptorLengthLo
    pokeByteOff p 2 iousbhidReportDescHidDescriptorLengthHi

{-# NOINLINE iousbhidReportDescStructType #-}
iousbhidReportDescStructType :: Ptr CType
iousbhidReportDescStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBHIDReportDesc :: IOUSBHIDReportDesc -> Arg
argIOUSBHIDReportDesc = mkStorableArg iousbhidReportDescStructType

retIOUSBHIDReportDesc :: RetType IOUSBHIDReportDesc
retIOUSBHIDReportDesc = mkStorableRetType iousbhidReportDescStructType

-- | IOUSBInterfaceAssociationDescriptor
--
-- USB Inerface Association Descriptor.  ECN to the USB 2.0 Spec.             See the USB Specification at http://www.usb.org.             USB 3.0 9.6.4: Interface Association
data IOUSBInterfaceAssociationDescriptor = IOUSBInterfaceAssociationDescriptor
  { iousbInterfaceAssociationDescriptorBLength :: !CUChar
  , iousbInterfaceAssociationDescriptorBDescriptorType :: !CUChar
  , iousbInterfaceAssociationDescriptorBFirstInterface :: !CUChar
  , iousbInterfaceAssociationDescriptorBInterfaceCount :: !CUChar
  , iousbInterfaceAssociationDescriptorBFunctionClass :: !CUChar
  , iousbInterfaceAssociationDescriptorBFunctionSubClass :: !CUChar
  , iousbInterfaceAssociationDescriptorBFunctionProtocol :: !CUChar
  , iousbInterfaceAssociationDescriptorIFunction :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBInterfaceAssociationDescriptor where
  sizeOf    _ = 8
  alignment _ = 1
  peek p = IOUSBInterfaceAssociationDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
  poke p (IOUSBInterfaceAssociationDescriptor {..}) = do
    pokeByteOff p 0 iousbInterfaceAssociationDescriptorBLength
    pokeByteOff p 1 iousbInterfaceAssociationDescriptorBDescriptorType
    pokeByteOff p 2 iousbInterfaceAssociationDescriptorBFirstInterface
    pokeByteOff p 3 iousbInterfaceAssociationDescriptorBInterfaceCount
    pokeByteOff p 4 iousbInterfaceAssociationDescriptorBFunctionClass
    pokeByteOff p 5 iousbInterfaceAssociationDescriptorBFunctionSubClass
    pokeByteOff p 6 iousbInterfaceAssociationDescriptorBFunctionProtocol
    pokeByteOff p 7 iousbInterfaceAssociationDescriptorIFunction

{-# NOINLINE iousbInterfaceAssociationDescriptorStructType #-}
iousbInterfaceAssociationDescriptorStructType :: Ptr CType
iousbInterfaceAssociationDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBInterfaceAssociationDescriptor :: IOUSBInterfaceAssociationDescriptor -> Arg
argIOUSBInterfaceAssociationDescriptor = mkStorableArg iousbInterfaceAssociationDescriptorStructType

retIOUSBInterfaceAssociationDescriptor :: RetType IOUSBInterfaceAssociationDescriptor
retIOUSBInterfaceAssociationDescriptor = mkStorableRetType iousbInterfaceAssociationDescriptorStructType

-- | IOUSBInterfaceDescriptor
--
-- Descriptor for a USB Interface.  See the USB Specification at             http://www.usb.org.             USB 2.0 9.6.5: Interface
data IOUSBInterfaceDescriptor = IOUSBInterfaceDescriptor
  { iousbInterfaceDescriptorBLength :: !CUChar
  , iousbInterfaceDescriptorBDescriptorType :: !CUChar
  , iousbInterfaceDescriptorBInterfaceNumber :: !CUChar
  , iousbInterfaceDescriptorBAlternateSetting :: !CUChar
  , iousbInterfaceDescriptorBNumEndpoints :: !CUChar
  , iousbInterfaceDescriptorBInterfaceClass :: !CUChar
  , iousbInterfaceDescriptorBInterfaceSubClass :: !CUChar
  , iousbInterfaceDescriptorBInterfaceProtocol :: !CUChar
  , iousbInterfaceDescriptorIInterface :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBInterfaceDescriptor where
  sizeOf    _ = 9
  alignment _ = 1
  peek p = IOUSBInterfaceDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBInterfaceDescriptor {..}) = do
    pokeByteOff p 0 iousbInterfaceDescriptorBLength
    pokeByteOff p 1 iousbInterfaceDescriptorBDescriptorType
    pokeByteOff p 2 iousbInterfaceDescriptorBInterfaceNumber
    pokeByteOff p 3 iousbInterfaceDescriptorBAlternateSetting
    pokeByteOff p 4 iousbInterfaceDescriptorBNumEndpoints
    pokeByteOff p 5 iousbInterfaceDescriptorBInterfaceClass
    pokeByteOff p 6 iousbInterfaceDescriptorBInterfaceSubClass
    pokeByteOff p 7 iousbInterfaceDescriptorBInterfaceProtocol
    pokeByteOff p 8 iousbInterfaceDescriptorIInterface

{-# NOINLINE iousbInterfaceDescriptorStructType #-}
iousbInterfaceDescriptorStructType :: Ptr CType
iousbInterfaceDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBInterfaceDescriptor :: IOUSBInterfaceDescriptor -> Arg
argIOUSBInterfaceDescriptor = mkStorableArg iousbInterfaceDescriptorStructType

retIOUSBInterfaceDescriptor :: RetType IOUSBInterfaceDescriptor
retIOUSBInterfaceDescriptor = mkStorableRetType iousbInterfaceDescriptorStructType

-- | IOUSBSuperSpeedEndpointCompanionDescriptor
--
-- Descriptor for a SuperSpeed USB Endpoint Companion.             See the USB Specification at http://www.usb.org.             USB 3.1 9.6.7: SuperSpeed Endpoint Companion
data IOUSBSuperSpeedEndpointCompanionDescriptor = IOUSBSuperSpeedEndpointCompanionDescriptor
  { iousbSuperSpeedEndpointCompanionDescriptorBLength :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorBDescriptorType :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorBMaxBurst :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorBmAttributes :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorWBytesPerInterval :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBSuperSpeedEndpointCompanionDescriptor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBSuperSpeedEndpointCompanionDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (IOUSBSuperSpeedEndpointCompanionDescriptor {..}) = do
    pokeByteOff p 0 iousbSuperSpeedEndpointCompanionDescriptorBLength
    pokeByteOff p 1 iousbSuperSpeedEndpointCompanionDescriptorBDescriptorType
    pokeByteOff p 2 iousbSuperSpeedEndpointCompanionDescriptorBMaxBurst
    pokeByteOff p 3 iousbSuperSpeedEndpointCompanionDescriptorBmAttributes
    pokeByteOff p 4 iousbSuperSpeedEndpointCompanionDescriptorWBytesPerInterval

{-# NOINLINE iousbSuperSpeedEndpointCompanionDescriptorStructType #-}
iousbSuperSpeedEndpointCompanionDescriptorStructType :: Ptr CType
iousbSuperSpeedEndpointCompanionDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBSuperSpeedEndpointCompanionDescriptor :: IOUSBSuperSpeedEndpointCompanionDescriptor -> Arg
argIOUSBSuperSpeedEndpointCompanionDescriptor = mkStorableArg iousbSuperSpeedEndpointCompanionDescriptorStructType

retIOUSBSuperSpeedEndpointCompanionDescriptor :: RetType IOUSBSuperSpeedEndpointCompanionDescriptor
retIOUSBSuperSpeedEndpointCompanionDescriptor = mkStorableRetType iousbSuperSpeedEndpointCompanionDescriptorStructType

-- | IOUSBSuperSpeedHubDescriptor
--
-- Descriptor for a Super Speed USB hub.             See the USB Specification at http://www.usb.org.             USB 3.0 10.13.2.1: SuperSpeed Hub Descriptor
data IOUSBSuperSpeedHubDescriptor = IOUSBSuperSpeedHubDescriptor
  { iousbSuperSpeedHubDescriptorBLength :: !CUChar
  , iousbSuperSpeedHubDescriptorBDescriptorType :: !CUChar
  , iousbSuperSpeedHubDescriptorBNumberPorts :: !CUChar
  , iousbSuperSpeedHubDescriptorWHubCharacteristics :: !CUShort
  , iousbSuperSpeedHubDescriptorBPowerOnToPowerGood :: !CUChar
  , iousbSuperSpeedHubDescriptorBHubControllerCurrent :: !CUChar
  , iousbSuperSpeedHubDescriptorBHubDecodeLatency :: !CUChar
  , iousbSuperSpeedHubDescriptorWHubDelay :: !CUShort
  , iousbSuperSpeedHubDescriptorDeviceRemovable :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBSuperSpeedHubDescriptor where
  sizeOf    _ = 14
  alignment _ = 2
  peek p = IOUSBSuperSpeedHubDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (IOUSBSuperSpeedHubDescriptor {..}) = do
    pokeByteOff p 0 iousbSuperSpeedHubDescriptorBLength
    pokeByteOff p 1 iousbSuperSpeedHubDescriptorBDescriptorType
    pokeByteOff p 2 iousbSuperSpeedHubDescriptorBNumberPorts
    pokeByteOff p 4 iousbSuperSpeedHubDescriptorWHubCharacteristics
    pokeByteOff p 6 iousbSuperSpeedHubDescriptorBPowerOnToPowerGood
    pokeByteOff p 7 iousbSuperSpeedHubDescriptorBHubControllerCurrent
    pokeByteOff p 8 iousbSuperSpeedHubDescriptorBHubDecodeLatency
    pokeByteOff p 10 iousbSuperSpeedHubDescriptorWHubDelay
    pokeByteOff p 12 iousbSuperSpeedHubDescriptorDeviceRemovable

{-# NOINLINE iousbSuperSpeedHubDescriptorStructType #-}
iousbSuperSpeedHubDescriptorStructType :: Ptr CType
iousbSuperSpeedHubDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argIOUSBSuperSpeedHubDescriptor :: IOUSBSuperSpeedHubDescriptor -> Arg
argIOUSBSuperSpeedHubDescriptor = mkStorableArg iousbSuperSpeedHubDescriptorStructType

retIOUSBSuperSpeedHubDescriptor :: RetType IOUSBSuperSpeedHubDescriptor
retIOUSBSuperSpeedHubDescriptor = mkStorableRetType iousbSuperSpeedHubDescriptorStructType

-- | IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
--
-- Descriptor for a SuperSpeedPlus Isochronout USB Endpoint Companion.             See the USB Specification at http://www.usb.org.             USB 3.1 9.6.8: SuperSpeedPlus Isochronous Endpoint Companion
data IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
  { iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBLength :: !CUChar
  , iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBDescriptorType :: !CUChar
  , iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorWReserved :: !CUShort
  , iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorDwBytesPerInterval :: !CUInt
  } deriving (Eq, Show)

instance Storable IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor {..}) = do
    pokeByteOff p 0 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBLength
    pokeByteOff p 1 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBDescriptorType
    pokeByteOff p 2 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorWReserved
    pokeByteOff p 4 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorDwBytesPerInterval

{-# NOINLINE iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType #-}
iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType :: Ptr CType
iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint]

argIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor :: IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor -> Arg
argIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = mkStorableArg iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType

retIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor :: RetType IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
retIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = mkStorableRetType iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType

data NXEvent = NXEvent
  { nxEventType :: !CInt
  , nxEventLocation :: !(Ptr ())
  , nxEventTime :: !CULong
  , nxEventFlags :: !CInt
  , nxEventWindow :: !CUInt
  , nxEventService_id :: !CULong
  , nxEventExt_pid :: !CInt
  , nxEventData :: !CInt
  } deriving (Eq, Show)

instance Storable NXEvent where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = NXEvent <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 44
  poke p (NXEvent {..}) = do
    pokeByteOff p 0 nxEventType
    pokeByteOff p 8 nxEventLocation
    pokeByteOff p 16 nxEventTime
    pokeByteOff p 24 nxEventFlags
    pokeByteOff p 28 nxEventWindow
    pokeByteOff p 32 nxEventService_id
    pokeByteOff p 40 nxEventExt_pid
    pokeByteOff p 44 nxEventData

{-# NOINLINE nxEventStructType #-}
nxEventStructType :: Ptr CType
nxEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_pointer, ffi_type_ulong, ffi_type_sint, ffi_type_uint, ffi_type_ulong, ffi_type_sint, ffi_type_sint]

argNXEvent :: NXEvent -> Arg
argNXEvent = mkStorableArg nxEventStructType

retNXEvent :: RetType NXEvent
retNXEvent = mkStorableRetType nxEventStructType

data NXEventExt = NXEventExt
  { nxEventExtPayload :: !(Ptr ())
  , nxEventExtExtension :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable NXEventExt where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = NXEventExt <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (NXEventExt {..}) = do
    pokeByteOff p 0 nxEventExtPayload
    pokeByteOff p 8 nxEventExtExtension

{-# NOINLINE nxEventExtStructType #-}
nxEventExtStructType :: Ptr CType
nxEventExtStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argNXEventExt :: NXEventExt -> Arg
argNXEventExt = mkStorableArg nxEventExtStructType

retNXEventExt :: RetType NXEventExt
retNXEventExt = mkStorableRetType nxEventExtStructType

data NXKeyMapping = NXKeyMapping
  { nxKeyMappingSize :: !CInt
  , nxKeyMappingMapping :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable NXKeyMapping where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = NXKeyMapping <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (NXKeyMapping {..}) = do
    pokeByteOff p 0 nxKeyMappingSize
    pokeByteOff p 8 nxKeyMappingMapping

{-# NOINLINE nxKeyMappingStructType #-}
nxKeyMappingStructType :: Ptr CType
nxKeyMappingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_pointer]

argNXKeyMapping :: NXKeyMapping -> Arg
argNXKeyMapping = mkStorableArg nxKeyMappingStructType

retNXKeyMapping :: RetType NXKeyMapping
retNXKeyMapping = mkStorableRetType nxKeyMappingStructType

data NXPoint = NXPoint
  { nxPointX :: !CFloat
  , nxPointY :: !CFloat
  } deriving (Eq, Show)

instance Storable NXPoint where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = NXPoint <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (NXPoint {..}) = do
    pokeByteOff p 0 nxPointX
    pokeByteOff p 4 nxPointY

{-# NOINLINE nxPointStructType #-}
nxPointStructType :: Ptr CType
nxPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argNXPoint :: NXPoint -> Arg
argNXPoint = mkStorableArg nxPointStructType

retNXPoint :: RetType NXPoint
retNXPoint = mkStorableRetType nxPointStructType

data NXSize = NXSize
  { nxSizeWidth :: !CFloat
  , nxSizeHeight :: !CFloat
  } deriving (Eq, Show)

instance Storable NXSize where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = NXSize <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (NXSize {..}) = do
    pokeByteOff p 0 nxSizeWidth
    pokeByteOff p 4 nxSizeHeight

{-# NOINLINE nxSizeStructType #-}
nxSizeStructType :: Ptr CType
nxSizeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argNXSize :: NXSize -> Arg
argNXSize = mkStorableArg nxSizeStructType

retNXSize :: RetType NXSize
retNXSize = mkStorableRetType nxSizeStructType

data NXTabletPointData = NXTabletPointData
  { nxTabletPointDataX :: !CInt
  , nxTabletPointDataY :: !CInt
  , nxTabletPointDataZ :: !CInt
  , nxTabletPointDataButtons :: !CUShort
  , nxTabletPointDataPressure :: !CUShort
  , nxTabletPointDataTilt :: !(Ptr ())
  , nxTabletPointDataRotation :: !CUShort
  , nxTabletPointDataTangentialPressure :: !CShort
  , nxTabletPointDataDeviceID :: !CUShort
  , nxTabletPointDataVendor1 :: !CShort
  , nxTabletPointDataVendor2 :: !CShort
  , nxTabletPointDataVendor3 :: !CShort
  } deriving (Eq, Show)

instance Storable NXTabletPointData where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = NXTabletPointData <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 26
    <*> peekByteOff p 28
    <*> peekByteOff p 30
    <*> peekByteOff p 32
    <*> peekByteOff p 34
  poke p (NXTabletPointData {..}) = do
    pokeByteOff p 0 nxTabletPointDataX
    pokeByteOff p 4 nxTabletPointDataY
    pokeByteOff p 8 nxTabletPointDataZ
    pokeByteOff p 12 nxTabletPointDataButtons
    pokeByteOff p 14 nxTabletPointDataPressure
    pokeByteOff p 16 nxTabletPointDataTilt
    pokeByteOff p 24 nxTabletPointDataRotation
    pokeByteOff p 26 nxTabletPointDataTangentialPressure
    pokeByteOff p 28 nxTabletPointDataDeviceID
    pokeByteOff p 30 nxTabletPointDataVendor1
    pokeByteOff p 32 nxTabletPointDataVendor2
    pokeByteOff p 34 nxTabletPointDataVendor3

{-# NOINLINE nxTabletPointDataStructType #-}
nxTabletPointDataStructType :: Ptr CType
nxTabletPointDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer, ffi_type_uint16, ffi_type_sint16, ffi_type_uint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argNXTabletPointData :: NXTabletPointData -> Arg
argNXTabletPointData = mkStorableArg nxTabletPointDataStructType

retNXTabletPointData :: RetType NXTabletPointData
retNXTabletPointData = mkStorableRetType nxTabletPointDataStructType

data NXTabletProximityData = NXTabletProximityData
  { nxTabletProximityDataVendorID :: !CUShort
  , nxTabletProximityDataTabletID :: !CUShort
  , nxTabletProximityDataPointerID :: !CUShort
  , nxTabletProximityDataDeviceID :: !CUShort
  , nxTabletProximityDataSystemTabletID :: !CUShort
  , nxTabletProximityDataVendorPointerType :: !CUShort
  , nxTabletProximityDataPointerSerialNumber :: !CUInt
  , nxTabletProximityDataUniqueID :: !CULong
  , nxTabletProximityDataCapabilityMask :: !CUInt
  , nxTabletProximityDataPointerType :: !CUChar
  , nxTabletProximityDataEnterProximity :: !CUChar
  , nxTabletProximityDataReserved1 :: !CShort
  } deriving (Eq, Show)

instance Storable NXTabletProximityData where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = NXTabletProximityData <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 29
    <*> peekByteOff p 30
  poke p (NXTabletProximityData {..}) = do
    pokeByteOff p 0 nxTabletProximityDataVendorID
    pokeByteOff p 2 nxTabletProximityDataTabletID
    pokeByteOff p 4 nxTabletProximityDataPointerID
    pokeByteOff p 6 nxTabletProximityDataDeviceID
    pokeByteOff p 8 nxTabletProximityDataSystemTabletID
    pokeByteOff p 10 nxTabletProximityDataVendorPointerType
    pokeByteOff p 12 nxTabletProximityDataPointerSerialNumber
    pokeByteOff p 16 nxTabletProximityDataUniqueID
    pokeByteOff p 24 nxTabletProximityDataCapabilityMask
    pokeByteOff p 28 nxTabletProximityDataPointerType
    pokeByteOff p 29 nxTabletProximityDataEnterProximity
    pokeByteOff p 30 nxTabletProximityDataReserved1

{-# NOINLINE nxTabletProximityDataStructType #-}
nxTabletProximityDataStructType :: Ptr CType
nxTabletProximityDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_ulong, ffi_type_uint, ffi_type_uint8, ffi_type_uint8, ffi_type_sint16]

argNXTabletProximityData :: NXTabletProximityData -> Arg
argNXTabletProximityData = mkStorableArg nxTabletProximityDataStructType

retNXTabletProximityData :: RetType NXTabletProximityData
retNXTabletProximityData = mkStorableRetType nxTabletProximityDataStructType

-- | UASPipeDescriptor
--
-- Structure used to specify the Mass Storage Specific UAS pipe usage descriptor
data UASPipeDescriptor = UASPipeDescriptor
  { uasPipeDescriptorBLength :: !CUChar
  , uasPipeDescriptorBDescriptorType :: !CUChar
  , uasPipeDescriptorBPipeID :: !CUChar
  , uasPipeDescriptorBReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable UASPipeDescriptor where
  sizeOf    _ = 4
  alignment _ = 1
  peek p = UASPipeDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (UASPipeDescriptor {..}) = do
    pokeByteOff p 0 uasPipeDescriptorBLength
    pokeByteOff p 1 uasPipeDescriptorBDescriptorType
    pokeByteOff p 2 uasPipeDescriptorBPipeID
    pokeByteOff p 3 uasPipeDescriptorBReserved

{-# NOINLINE uasPipeDescriptorStructType #-}
uasPipeDescriptorStructType :: Ptr CType
uasPipeDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argUASPipeDescriptor :: UASPipeDescriptor -> Arg
argUASPipeDescriptor = mkStorableArg uasPipeDescriptorStructType

retUASPipeDescriptor :: RetType UASPipeDescriptor
retUASPipeDescriptor = mkStorableRetType uasPipeDescriptorStructType
