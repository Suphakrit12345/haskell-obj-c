{-# LANGUAGE RecordWildCards #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.CoreText.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.CoreText.Internal.Enums

data ALMXGlyphEntry = ALMXGlyphEntry
  { almxGlyphEntryGlyphIndexOffset :: !CShort
  , almxGlyphEntryHorizontalAdvance :: !CShort
  , almxGlyphEntryXOffsetToHOrigin :: !CShort
  , almxGlyphEntryVerticalAdvance :: !CShort
  , almxGlyphEntryYOffsetToVOrigin :: !CShort
  } deriving (Eq, Show)

instance Storable ALMXGlyphEntry where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = ALMXGlyphEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (ALMXGlyphEntry {..}) = do
    pokeByteOff p 0 almxGlyphEntryGlyphIndexOffset
    pokeByteOff p 2 almxGlyphEntryHorizontalAdvance
    pokeByteOff p 4 almxGlyphEntryXOffsetToHOrigin
    pokeByteOff p 6 almxGlyphEntryVerticalAdvance
    pokeByteOff p 8 almxGlyphEntryYOffsetToVOrigin

{-# NOINLINE almxGlyphEntryStructType #-}
almxGlyphEntryStructType :: Ptr CType
almxGlyphEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argALMXGlyphEntry :: ALMXGlyphEntry -> Arg
argALMXGlyphEntry = mkStorableArg almxGlyphEntryStructType

retALMXGlyphEntry :: RetType ALMXGlyphEntry
retALMXGlyphEntry = mkStorableRetType almxGlyphEntryStructType

data ALMXHeader = ALMXHeader
  { almxHeaderVersion :: !CInt
  , almxHeaderFlags :: !CUShort
  , almxHeaderNMasters :: !CUShort
  , almxHeaderFirstGlyph :: !CUShort
  , almxHeaderLastGlyph :: !CUShort
  , almxHeaderLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ALMXHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ALMXHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (ALMXHeader {..}) = do
    pokeByteOff p 0 almxHeaderVersion
    pokeByteOff p 4 almxHeaderFlags
    pokeByteOff p 6 almxHeaderNMasters
    pokeByteOff p 8 almxHeaderFirstGlyph
    pokeByteOff p 10 almxHeaderLastGlyph
    pokeByteOff p 16 almxHeaderLookup

{-# NOINLINE almxHeaderStructType #-}
almxHeaderStructType :: Ptr CType
almxHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argALMXHeader :: ALMXHeader -> Arg
argALMXHeader = mkStorableArg almxHeaderStructType

retALMXHeader :: RetType ALMXHeader
retALMXHeader = mkStorableRetType almxHeaderStructType

data AnchorPoint = AnchorPoint
  { anchorPointX :: !CShort
  , anchorPointY :: !CShort
  } deriving (Eq, Show)

instance Storable AnchorPoint where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = AnchorPoint <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (AnchorPoint {..}) = do
    pokeByteOff p 0 anchorPointX
    pokeByteOff p 2 anchorPointY

{-# NOINLINE anchorPointStructType #-}
anchorPointStructType :: Ptr CType
anchorPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argAnchorPoint :: AnchorPoint -> Arg
argAnchorPoint = mkStorableArg anchorPointStructType

retAnchorPoint :: RetType AnchorPoint
retAnchorPoint = mkStorableRetType anchorPointStructType

data AnkrTable = AnkrTable
  { ankrTableVersion :: !CUShort
  , ankrTableFlags :: !CUShort
  , ankrTableLookupTableOffset :: !CUInt
  , ankrTableAnchorPointTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable AnkrTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AnkrTable <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AnkrTable {..}) = do
    pokeByteOff p 0 ankrTableVersion
    pokeByteOff p 2 ankrTableFlags
    pokeByteOff p 4 ankrTableLookupTableOffset
    pokeByteOff p 8 ankrTableAnchorPointTableOffset

{-# NOINLINE ankrTableStructType #-}
ankrTableStructType :: Ptr CType
ankrTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argAnkrTable :: AnkrTable -> Arg
argAnkrTable = mkStorableArg ankrTableStructType

retAnkrTable :: RetType AnkrTable
retAnkrTable = mkStorableRetType ankrTableStructType

-- | CTParagraphStyleSetting
--
-- This structure is used to alter the paragraph style.
--
-- spec                The specifier of the setting.
--
-- valueSize                The size of the value pointed to by the "value" field. This                must match the size of the value required by the                CTParagraphStyleSpecifier set in the "spec" field.
--
-- value                A reference to the value of the setting specified by the                "spec" field. The value must be in the proper range for the                spec value. The value must also be at least valueSize.
data CTParagraphStyleSetting = CTParagraphStyleSetting
  { ctParagraphStyleSettingSpec :: !CTParagraphStyleSpecifier
  , ctParagraphStyleSettingValueSize :: !CULong
  , ctParagraphStyleSettingValue :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CTParagraphStyleSetting where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = CTParagraphStyleSetting <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (CTParagraphStyleSetting {..}) = do
    pokeByteOff p 0 ctParagraphStyleSettingSpec
    pokeByteOff p 8 ctParagraphStyleSettingValueSize
    pokeByteOff p 16 ctParagraphStyleSettingValue

{-# NOINLINE ctParagraphStyleSettingStructType #-}
ctParagraphStyleSettingStructType :: Ptr CType
ctParagraphStyleSettingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_ulong, ffi_type_pointer]

argCTParagraphStyleSetting :: CTParagraphStyleSetting -> Arg
argCTParagraphStyleSetting = mkStorableArg ctParagraphStyleSettingStructType

retCTParagraphStyleSetting :: RetType CTParagraphStyleSetting
retCTParagraphStyleSetting = mkStorableRetType ctParagraphStyleSettingStructType

data FontVariation = FontVariation
  { fontVariationName :: !CUInt
  , fontVariationValue :: !CInt
  } deriving (Eq, Show)

instance Storable FontVariation where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = FontVariation <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (FontVariation {..}) = do
    pokeByteOff p 0 fontVariationName
    pokeByteOff p 4 fontVariationValue

{-# NOINLINE fontVariationStructType #-}
fontVariationStructType :: Ptr CType
fontVariationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint]

argFontVariation :: FontVariation -> Arg
argFontVariation = mkStorableArg fontVariationStructType

retFontVariation :: RetType FontVariation
retFontVariation = mkStorableRetType fontVariationStructType

data JustDirectionTable = JustDirectionTable
  { justDirectionTableJustClass :: !CUShort
  , justDirectionTableWidthDeltaClusters :: !CUShort
  , justDirectionTablePostcomp :: !CUShort
  , justDirectionTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable JustDirectionTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = JustDirectionTable <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (JustDirectionTable {..}) = do
    pokeByteOff p 0 justDirectionTableJustClass
    pokeByteOff p 2 justDirectionTableWidthDeltaClusters
    pokeByteOff p 4 justDirectionTablePostcomp
    pokeByteOff p 8 justDirectionTableLookup

{-# NOINLINE justDirectionTableStructType #-}
justDirectionTableStructType :: Ptr CType
justDirectionTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argJustDirectionTable :: JustDirectionTable -> Arg
argJustDirectionTable = mkStorableArg justDirectionTableStructType

retJustDirectionTable :: RetType JustDirectionTable
retJustDirectionTable = mkStorableRetType justDirectionTableStructType

data JustPCActionSubrecord = JustPCActionSubrecord
  { justPCActionSubrecordTheClass :: !CUShort
  , justPCActionSubrecordTheType :: !CUShort
  , justPCActionSubrecordLength :: !CUInt
  , justPCActionSubrecordData :: !CUInt
  } deriving (Eq, Show)

instance Storable JustPCActionSubrecord where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = JustPCActionSubrecord <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (JustPCActionSubrecord {..}) = do
    pokeByteOff p 0 justPCActionSubrecordTheClass
    pokeByteOff p 2 justPCActionSubrecordTheType
    pokeByteOff p 4 justPCActionSubrecordLength
    pokeByteOff p 8 justPCActionSubrecordData

{-# NOINLINE justPCActionSubrecordStructType #-}
justPCActionSubrecordStructType :: Ptr CType
justPCActionSubrecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argJustPCActionSubrecord :: JustPCActionSubrecord -> Arg
argJustPCActionSubrecord = mkStorableArg justPCActionSubrecordStructType

retJustPCActionSubrecord :: RetType JustPCActionSubrecord
retJustPCActionSubrecord = mkStorableRetType justPCActionSubrecordStructType

data JustPCConditionalAddAction = JustPCConditionalAddAction
  { justPCConditionalAddActionSubstThreshold :: !CInt
  , justPCConditionalAddActionAddGlyph :: !CUShort
  , justPCConditionalAddActionSubstGlyph :: !CUShort
  } deriving (Eq, Show)

instance Storable JustPCConditionalAddAction where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = JustPCConditionalAddAction <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (JustPCConditionalAddAction {..}) = do
    pokeByteOff p 0 justPCConditionalAddActionSubstThreshold
    pokeByteOff p 4 justPCConditionalAddActionAddGlyph
    pokeByteOff p 6 justPCConditionalAddActionSubstGlyph

{-# NOINLINE justPCConditionalAddActionStructType #-}
justPCConditionalAddActionStructType :: Ptr CType
justPCConditionalAddActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argJustPCConditionalAddAction :: JustPCConditionalAddAction -> Arg
argJustPCConditionalAddAction = mkStorableArg justPCConditionalAddActionStructType

retJustPCConditionalAddAction :: RetType JustPCConditionalAddAction
retJustPCConditionalAddAction = mkStorableRetType justPCConditionalAddActionStructType

data JustPCDuctilityAction = JustPCDuctilityAction
  { justPCDuctilityActionDuctilityAxis :: !CUInt
  , justPCDuctilityActionMinimumLimit :: !CInt
  , justPCDuctilityActionNoStretchValue :: !CInt
  , justPCDuctilityActionMaximumLimit :: !CInt
  } deriving (Eq, Show)

instance Storable JustPCDuctilityAction where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = JustPCDuctilityAction <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (JustPCDuctilityAction {..}) = do
    pokeByteOff p 0 justPCDuctilityActionDuctilityAxis
    pokeByteOff p 4 justPCDuctilityActionMinimumLimit
    pokeByteOff p 8 justPCDuctilityActionNoStretchValue
    pokeByteOff p 12 justPCDuctilityActionMaximumLimit

{-# NOINLINE justPCDuctilityActionStructType #-}
justPCDuctilityActionStructType :: Ptr CType
justPCDuctilityActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint, ffi_type_sint]

argJustPCDuctilityAction :: JustPCDuctilityAction -> Arg
argJustPCDuctilityAction = mkStorableArg justPCDuctilityActionStructType

retJustPCDuctilityAction :: RetType JustPCDuctilityAction
retJustPCDuctilityAction = mkStorableRetType justPCDuctilityActionStructType

data JustPCGlyphRepeatAddAction = JustPCGlyphRepeatAddAction
  { justPCGlyphRepeatAddActionFlags :: !CUShort
  , justPCGlyphRepeatAddActionGlyph :: !CUShort
  } deriving (Eq, Show)

instance Storable JustPCGlyphRepeatAddAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = JustPCGlyphRepeatAddAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (JustPCGlyphRepeatAddAction {..}) = do
    pokeByteOff p 0 justPCGlyphRepeatAddActionFlags
    pokeByteOff p 2 justPCGlyphRepeatAddActionGlyph

{-# NOINLINE justPCGlyphRepeatAddActionStructType #-}
justPCGlyphRepeatAddActionStructType :: Ptr CType
justPCGlyphRepeatAddActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argJustPCGlyphRepeatAddAction :: JustPCGlyphRepeatAddAction -> Arg
argJustPCGlyphRepeatAddAction = mkStorableArg justPCGlyphRepeatAddActionStructType

retJustPCGlyphRepeatAddAction :: RetType JustPCGlyphRepeatAddAction
retJustPCGlyphRepeatAddAction = mkStorableRetType justPCGlyphRepeatAddActionStructType

data JustPostcompTable = JustPostcompTable
  { justPostcompTableLookupTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable JustPostcompTable where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = JustPostcompTable <$> peekByteOff p 0
  poke p (JustPostcompTable {..}) =
    pokeByteOff p 0 justPostcompTableLookupTable

{-# NOINLINE justPostcompTableStructType #-}
justPostcompTableStructType :: Ptr CType
justPostcompTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argJustPostcompTable :: JustPostcompTable -> Arg
argJustPostcompTable = mkStorableArg justPostcompTableStructType

retJustPostcompTable :: RetType JustPostcompTable
retJustPostcompTable = mkStorableRetType justPostcompTableStructType

data JustTable = JustTable
  { justTableVersion :: !CInt
  , justTableFormat :: !CUShort
  , justTableHorizHeaderOffset :: !CUShort
  , justTableVertHeaderOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable JustTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = JustTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (JustTable {..}) = do
    pokeByteOff p 0 justTableVersion
    pokeByteOff p 4 justTableFormat
    pokeByteOff p 6 justTableHorizHeaderOffset
    pokeByteOff p 8 justTableVertHeaderOffset

{-# NOINLINE justTableStructType #-}
justTableStructType :: Ptr CType
justTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argJustTable :: JustTable -> Arg
argJustTable = mkStorableArg justTableStructType

retJustTable :: RetType JustTable
retJustTable = mkStorableRetType justTableStructType

data JustWidthDeltaEntry = JustWidthDeltaEntry
  { justWidthDeltaEntryJustClass :: !CUInt
  , justWidthDeltaEntryBeforeGrowLimit :: !CInt
  , justWidthDeltaEntryBeforeShrinkLimit :: !CInt
  , justWidthDeltaEntryAfterGrowLimit :: !CInt
  , justWidthDeltaEntryAfterShrinkLimit :: !CInt
  , justWidthDeltaEntryGrowFlags :: !CUShort
  , justWidthDeltaEntryShrinkFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable JustWidthDeltaEntry where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = JustWidthDeltaEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 22
  poke p (JustWidthDeltaEntry {..}) = do
    pokeByteOff p 0 justWidthDeltaEntryJustClass
    pokeByteOff p 4 justWidthDeltaEntryBeforeGrowLimit
    pokeByteOff p 8 justWidthDeltaEntryBeforeShrinkLimit
    pokeByteOff p 12 justWidthDeltaEntryAfterGrowLimit
    pokeByteOff p 16 justWidthDeltaEntryAfterShrinkLimit
    pokeByteOff p 20 justWidthDeltaEntryGrowFlags
    pokeByteOff p 22 justWidthDeltaEntryShrinkFlags

{-# NOINLINE justWidthDeltaEntryStructType #-}
justWidthDeltaEntryStructType :: Ptr CType
justWidthDeltaEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argJustWidthDeltaEntry :: JustWidthDeltaEntry -> Arg
argJustWidthDeltaEntry = mkStorableArg justWidthDeltaEntryStructType

retJustWidthDeltaEntry :: RetType JustWidthDeltaEntry
retJustWidthDeltaEntry = mkStorableRetType justWidthDeltaEntryStructType

data KernKerningPair = KernKerningPair
  { kernKerningPairLeft :: !CUShort
  , kernKerningPairRight :: !CUShort
  } deriving (Eq, Show)

instance Storable KernKerningPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernKerningPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernKerningPair {..}) = do
    pokeByteOff p 0 kernKerningPairLeft
    pokeByteOff p 2 kernKerningPairRight

{-# NOINLINE kernKerningPairStructType #-}
kernKerningPairStructType :: Ptr CType
kernKerningPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKernKerningPair :: KernKerningPair -> Arg
argKernKerningPair = mkStorableArg kernKerningPairStructType

retKernKerningPair :: RetType KernKerningPair
retKernKerningPair = mkStorableRetType kernKerningPairStructType

data KernStateEntry = KernStateEntry
  { kernStateEntryNewState :: !CUShort
  , kernStateEntryFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable KernStateEntry where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernStateEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernStateEntry {..}) = do
    pokeByteOff p 0 kernStateEntryNewState
    pokeByteOff p 2 kernStateEntryFlags

{-# NOINLINE kernStateEntryStructType #-}
kernStateEntryStructType :: Ptr CType
kernStateEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKernStateEntry :: KernStateEntry -> Arg
argKernStateEntry = mkStorableArg kernStateEntryStructType

retKernStateEntry :: RetType KernStateEntry
retKernStateEntry = mkStorableRetType kernStateEntryStructType

data KerxAnchorPointAction = KerxAnchorPointAction
  { kerxAnchorPointActionMarkAnchorPoint :: !CUShort
  , kerxAnchorPointActionCurrAnchorPoint :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxAnchorPointAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxAnchorPointAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxAnchorPointAction {..}) = do
    pokeByteOff p 0 kerxAnchorPointActionMarkAnchorPoint
    pokeByteOff p 2 kerxAnchorPointActionCurrAnchorPoint

{-# NOINLINE kerxAnchorPointActionStructType #-}
kerxAnchorPointActionStructType :: Ptr CType
kerxAnchorPointActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxAnchorPointAction :: KerxAnchorPointAction -> Arg
argKerxAnchorPointAction = mkStorableArg kerxAnchorPointActionStructType

retKerxAnchorPointAction :: RetType KerxAnchorPointAction
retKerxAnchorPointAction = mkStorableRetType kerxAnchorPointActionStructType

data KerxControlPointAction = KerxControlPointAction
  { kerxControlPointActionMarkControlPoint :: !CUShort
  , kerxControlPointActionCurrControlPoint :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxControlPointAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxControlPointAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxControlPointAction {..}) = do
    pokeByteOff p 0 kerxControlPointActionMarkControlPoint
    pokeByteOff p 2 kerxControlPointActionCurrControlPoint

{-# NOINLINE kerxControlPointActionStructType #-}
kerxControlPointActionStructType :: Ptr CType
kerxControlPointActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxControlPointAction :: KerxControlPointAction -> Arg
argKerxControlPointAction = mkStorableArg kerxControlPointActionStructType

retKerxControlPointAction :: RetType KerxControlPointAction
retKerxControlPointAction = mkStorableRetType kerxControlPointActionStructType

data KerxControlPointEntry = KerxControlPointEntry
  { kerxControlPointEntryNewState :: !CUShort
  , kerxControlPointEntryFlags :: !CUShort
  , kerxControlPointEntryActionIndex :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxControlPointEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxControlPointEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (KerxControlPointEntry {..}) = do
    pokeByteOff p 0 kerxControlPointEntryNewState
    pokeByteOff p 2 kerxControlPointEntryFlags
    pokeByteOff p 4 kerxControlPointEntryActionIndex

{-# NOINLINE kerxControlPointEntryStructType #-}
kerxControlPointEntryStructType :: Ptr CType
kerxControlPointEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxControlPointEntry :: KerxControlPointEntry -> Arg
argKerxControlPointEntry = mkStorableArg kerxControlPointEntryStructType

retKerxControlPointEntry :: RetType KerxControlPointEntry
retKerxControlPointEntry = mkStorableRetType kerxControlPointEntryStructType

data KerxCoordinateAction = KerxCoordinateAction
  { kerxCoordinateActionMarkX :: !CUShort
  , kerxCoordinateActionMarkY :: !CUShort
  , kerxCoordinateActionCurrX :: !CUShort
  , kerxCoordinateActionCurrY :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxCoordinateAction where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = KerxCoordinateAction <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (KerxCoordinateAction {..}) = do
    pokeByteOff p 0 kerxCoordinateActionMarkX
    pokeByteOff p 2 kerxCoordinateActionMarkY
    pokeByteOff p 4 kerxCoordinateActionCurrX
    pokeByteOff p 6 kerxCoordinateActionCurrY

{-# NOINLINE kerxCoordinateActionStructType #-}
kerxCoordinateActionStructType :: Ptr CType
kerxCoordinateActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxCoordinateAction :: KerxCoordinateAction -> Arg
argKerxCoordinateAction = mkStorableArg kerxCoordinateActionStructType

retKerxCoordinateAction :: RetType KerxCoordinateAction
retKerxCoordinateAction = mkStorableRetType kerxCoordinateActionStructType

data KerxIndexArrayHeader = KerxIndexArrayHeader
  { kerxIndexArrayHeaderFlags :: !CUInt
  , kerxIndexArrayHeaderRowCount :: !CUShort
  , kerxIndexArrayHeaderColumnCount :: !CUShort
  , kerxIndexArrayHeaderRowIndexTableOffset :: !CUInt
  , kerxIndexArrayHeaderColumnIndexTableOffset :: !CUInt
  , kerxIndexArrayHeaderKerningArrayOffset :: !CUInt
  , kerxIndexArrayHeaderKerningVectorOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable KerxIndexArrayHeader where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = KerxIndexArrayHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
  poke p (KerxIndexArrayHeader {..}) = do
    pokeByteOff p 0 kerxIndexArrayHeaderFlags
    pokeByteOff p 4 kerxIndexArrayHeaderRowCount
    pokeByteOff p 6 kerxIndexArrayHeaderColumnCount
    pokeByteOff p 8 kerxIndexArrayHeaderRowIndexTableOffset
    pokeByteOff p 12 kerxIndexArrayHeaderColumnIndexTableOffset
    pokeByteOff p 16 kerxIndexArrayHeaderKerningArrayOffset
    pokeByteOff p 20 kerxIndexArrayHeaderKerningVectorOffset

{-# NOINLINE kerxIndexArrayHeaderStructType #-}
kerxIndexArrayHeaderStructType :: Ptr CType
kerxIndexArrayHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argKerxIndexArrayHeader :: KerxIndexArrayHeader -> Arg
argKerxIndexArrayHeader = mkStorableArg kerxIndexArrayHeaderStructType

retKerxIndexArrayHeader :: RetType KerxIndexArrayHeader
retKerxIndexArrayHeader = mkStorableRetType kerxIndexArrayHeaderStructType

data KerxKerningPair = KerxKerningPair
  { kerxKerningPairLeft :: !CUShort
  , kerxKerningPairRight :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxKerningPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxKerningPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxKerningPair {..}) = do
    pokeByteOff p 0 kerxKerningPairLeft
    pokeByteOff p 2 kerxKerningPairRight

{-# NOINLINE kerxKerningPairStructType #-}
kerxKerningPairStructType :: Ptr CType
kerxKerningPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxKerningPair :: KerxKerningPair -> Arg
argKerxKerningPair = mkStorableArg kerxKerningPairStructType

retKerxKerningPair :: RetType KerxKerningPair
retKerxKerningPair = mkStorableRetType kerxKerningPairStructType

data KerxStateEntry = KerxStateEntry
  { kerxStateEntryNewState :: !CUShort
  , kerxStateEntryFlags :: !CUShort
  , kerxStateEntryValueIndex :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxStateEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxStateEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (KerxStateEntry {..}) = do
    pokeByteOff p 0 kerxStateEntryNewState
    pokeByteOff p 2 kerxStateEntryFlags
    pokeByteOff p 4 kerxStateEntryValueIndex

{-# NOINLINE kerxStateEntryStructType #-}
kerxStateEntryStructType :: Ptr CType
kerxStateEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxStateEntry :: KerxStateEntry -> Arg
argKerxStateEntry = mkStorableArg kerxStateEntryStructType

retKerxStateEntry :: RetType KerxStateEntry
retKerxStateEntry = mkStorableRetType kerxStateEntryStructType

data LcarCaretTable = LcarCaretTable
  { lcarCaretTableVersion :: !CInt
  , lcarCaretTableFormat :: !CUShort
  , lcarCaretTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable LcarCaretTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = LcarCaretTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (LcarCaretTable {..}) = do
    pokeByteOff p 0 lcarCaretTableVersion
    pokeByteOff p 4 lcarCaretTableFormat
    pokeByteOff p 8 lcarCaretTableLookup

{-# NOINLINE lcarCaretTableStructType #-}
lcarCaretTableStructType :: Ptr CType
lcarCaretTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_pointer]

argLcarCaretTable :: LcarCaretTable -> Arg
argLcarCaretTable = mkStorableArg lcarCaretTableStructType

retLcarCaretTable :: RetType LcarCaretTable
retLcarCaretTable = mkStorableRetType lcarCaretTableStructType

data LtagStringRange = LtagStringRange
  { ltagStringRangeOffset :: !CUShort
  , ltagStringRangeLength :: !CUShort
  } deriving (Eq, Show)

instance Storable LtagStringRange where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = LtagStringRange <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (LtagStringRange {..}) = do
    pokeByteOff p 0 ltagStringRangeOffset
    pokeByteOff p 2 ltagStringRangeLength

{-# NOINLINE ltagStringRangeStructType #-}
ltagStringRangeStructType :: Ptr CType
ltagStringRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argLtagStringRange :: LtagStringRange -> Arg
argLtagStringRange = mkStorableArg ltagStringRangeStructType

retLtagStringRange :: RetType LtagStringRange
retLtagStringRange = mkStorableRetType ltagStringRangeStructType

data MortFeatureEntry = MortFeatureEntry
  { mortFeatureEntryFeatureType :: !CUShort
  , mortFeatureEntryFeatureSelector :: !CUShort
  , mortFeatureEntryEnableFlags :: !CUInt
  , mortFeatureEntryDisableFlags :: !CUInt
  } deriving (Eq, Show)

instance Storable MortFeatureEntry where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = MortFeatureEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (MortFeatureEntry {..}) = do
    pokeByteOff p 0 mortFeatureEntryFeatureType
    pokeByteOff p 2 mortFeatureEntryFeatureSelector
    pokeByteOff p 4 mortFeatureEntryEnableFlags
    pokeByteOff p 8 mortFeatureEntryDisableFlags

{-# NOINLINE mortFeatureEntryStructType #-}
mortFeatureEntryStructType :: Ptr CType
mortFeatureEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argMortFeatureEntry :: MortFeatureEntry -> Arg
argMortFeatureEntry = mkStorableArg mortFeatureEntryStructType

retMortFeatureEntry :: RetType MortFeatureEntry
retMortFeatureEntry = mkStorableRetType mortFeatureEntryStructType

data MortSwashSubtable = MortSwashSubtable
  { mortSwashSubtableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MortSwashSubtable where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = MortSwashSubtable <$> peekByteOff p 0
  poke p (MortSwashSubtable {..}) =
    pokeByteOff p 0 mortSwashSubtableLookup

{-# NOINLINE mortSwashSubtableStructType #-}
mortSwashSubtableStructType :: Ptr CType
mortSwashSubtableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argMortSwashSubtable :: MortSwashSubtable -> Arg
argMortSwashSubtable = mkStorableArg mortSwashSubtableStructType

retMortSwashSubtable :: RetType MortSwashSubtable
retMortSwashSubtable = mkStorableRetType mortSwashSubtableStructType

data OpbdSideValues = OpbdSideValues
  { opbdSideValuesLeftSideShift :: !CShort
  , opbdSideValuesTopSideShift :: !CShort
  , opbdSideValuesRightSideShift :: !CShort
  , opbdSideValuesBottomSideShift :: !CShort
  } deriving (Eq, Show)

instance Storable OpbdSideValues where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = OpbdSideValues <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (OpbdSideValues {..}) = do
    pokeByteOff p 0 opbdSideValuesLeftSideShift
    pokeByteOff p 2 opbdSideValuesTopSideShift
    pokeByteOff p 4 opbdSideValuesRightSideShift
    pokeByteOff p 6 opbdSideValuesBottomSideShift

{-# NOINLINE opbdSideValuesStructType #-}
opbdSideValuesStructType :: Ptr CType
opbdSideValuesStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argOpbdSideValues :: OpbdSideValues -> Arg
argOpbdSideValues = mkStorableArg opbdSideValuesStructType

retOpbdSideValues :: RetType OpbdSideValues
retOpbdSideValues = mkStorableRetType opbdSideValuesStructType

data OpbdTable = OpbdTable
  { opbdTableVersion :: !CInt
  , opbdTableFormat :: !CUShort
  , opbdTableLookupTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable OpbdTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = OpbdTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (OpbdTable {..}) = do
    pokeByteOff p 0 opbdTableVersion
    pokeByteOff p 4 opbdTableFormat
    pokeByteOff p 8 opbdTableLookupTable

{-# NOINLINE opbdTableStructType #-}
opbdTableStructType :: Ptr CType
opbdTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_pointer]

argOpbdTable :: OpbdTable -> Arg
argOpbdTable = mkStorableArg opbdTableStructType

retOpbdTable :: RetType OpbdTable
retOpbdTable = mkStorableRetType opbdTableStructType

data PropLookupSegment = PropLookupSegment
  { propLookupSegmentLastGlyph :: !CUShort
  , propLookupSegmentFirstGlyph :: !CUShort
  , propLookupSegmentValue :: !CUShort
  } deriving (Eq, Show)

instance Storable PropLookupSegment where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = PropLookupSegment <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (PropLookupSegment {..}) = do
    pokeByteOff p 0 propLookupSegmentLastGlyph
    pokeByteOff p 2 propLookupSegmentFirstGlyph
    pokeByteOff p 4 propLookupSegmentValue

{-# NOINLINE propLookupSegmentStructType #-}
propLookupSegmentStructType :: Ptr CType
propLookupSegmentStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argPropLookupSegment :: PropLookupSegment -> Arg
argPropLookupSegment = mkStorableArg propLookupSegmentStructType

retPropLookupSegment :: RetType PropLookupSegment
retPropLookupSegment = mkStorableRetType propLookupSegmentStructType

data PropLookupSingle = PropLookupSingle
  { propLookupSingleGlyph :: !CUShort
  , propLookupSingleProps :: !CUShort
  } deriving (Eq, Show)

instance Storable PropLookupSingle where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = PropLookupSingle <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (PropLookupSingle {..}) = do
    pokeByteOff p 0 propLookupSingleGlyph
    pokeByteOff p 2 propLookupSingleProps

{-# NOINLINE propLookupSingleStructType #-}
propLookupSingleStructType :: Ptr CType
propLookupSingleStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argPropLookupSingle :: PropLookupSingle -> Arg
argPropLookupSingle = mkStorableArg propLookupSingleStructType

retPropLookupSingle :: RetType PropLookupSingle
retPropLookupSingle = mkStorableRetType propLookupSingleStructType

data PropTable = PropTable
  { propTableVersion :: !CInt
  , propTableFormat :: !CUShort
  , propTableDefaultProps :: !CUShort
  , propTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable PropTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = PropTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (PropTable {..}) = do
    pokeByteOff p 0 propTableVersion
    pokeByteOff p 4 propTableFormat
    pokeByteOff p 6 propTableDefaultProps
    pokeByteOff p 8 propTableLookup

{-# NOINLINE propTableStructType #-}
propTableStructType :: Ptr CType
propTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argPropTable :: PropTable -> Arg
argPropTable = mkStorableArg propTableStructType

retPropTable :: RetType PropTable
retPropTable = mkStorableRetType propTableStructType

data ROTAGlyphEntry = ROTAGlyphEntry
  { rotaGlyphEntryGlyphIndexOffset :: !CShort
  , rotaGlyphEntryHBaselineOffset :: !CShort
  , rotaGlyphEntryVBaselineOffset :: !CShort
  } deriving (Eq, Show)

instance Storable ROTAGlyphEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = ROTAGlyphEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (ROTAGlyphEntry {..}) = do
    pokeByteOff p 0 rotaGlyphEntryGlyphIndexOffset
    pokeByteOff p 2 rotaGlyphEntryHBaselineOffset
    pokeByteOff p 4 rotaGlyphEntryVBaselineOffset

{-# NOINLINE rotaGlyphEntryStructType #-}
rotaGlyphEntryStructType :: Ptr CType
rotaGlyphEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argROTAGlyphEntry :: ROTAGlyphEntry -> Arg
argROTAGlyphEntry = mkStorableArg rotaGlyphEntryStructType

retROTAGlyphEntry :: RetType ROTAGlyphEntry
retROTAGlyphEntry = mkStorableRetType rotaGlyphEntryStructType

data ROTAHeader = ROTAHeader
  { rotaHeaderVersion :: !CInt
  , rotaHeaderFlags :: !CUShort
  , rotaHeaderNMasters :: !CUShort
  , rotaHeaderFirstGlyph :: !CUShort
  , rotaHeaderLastGlyph :: !CUShort
  , rotaHeaderLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ROTAHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ROTAHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (ROTAHeader {..}) = do
    pokeByteOff p 0 rotaHeaderVersion
    pokeByteOff p 4 rotaHeaderFlags
    pokeByteOff p 6 rotaHeaderNMasters
    pokeByteOff p 8 rotaHeaderFirstGlyph
    pokeByteOff p 10 rotaHeaderLastGlyph
    pokeByteOff p 16 rotaHeaderLookup

{-# NOINLINE rotaHeaderStructType #-}
rotaHeaderStructType :: Ptr CType
rotaHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argROTAHeader :: ROTAHeader -> Arg
argROTAHeader = mkStorableArg rotaHeaderStructType

retROTAHeader :: RetType ROTAHeader
retROTAHeader = mkStorableRetType rotaHeaderStructType

data SFNTLookupBinarySearchHeader = SFNTLookupBinarySearchHeader
  { sfntLookupBinarySearchHeaderUnitSize :: !CUShort
  , sfntLookupBinarySearchHeaderNUnits :: !CUShort
  , sfntLookupBinarySearchHeaderSearchRange :: !CUShort
  , sfntLookupBinarySearchHeaderEntrySelector :: !CUShort
  , sfntLookupBinarySearchHeaderRangeShift :: !CUShort
  } deriving (Eq, Show)

instance Storable SFNTLookupBinarySearchHeader where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = SFNTLookupBinarySearchHeader <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (SFNTLookupBinarySearchHeader {..}) = do
    pokeByteOff p 0 sfntLookupBinarySearchHeaderUnitSize
    pokeByteOff p 2 sfntLookupBinarySearchHeaderNUnits
    pokeByteOff p 4 sfntLookupBinarySearchHeaderSearchRange
    pokeByteOff p 6 sfntLookupBinarySearchHeaderEntrySelector
    pokeByteOff p 8 sfntLookupBinarySearchHeaderRangeShift

{-# NOINLINE sfntLookupBinarySearchHeaderStructType #-}
sfntLookupBinarySearchHeaderStructType :: Ptr CType
sfntLookupBinarySearchHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSFNTLookupBinarySearchHeader :: SFNTLookupBinarySearchHeader -> Arg
argSFNTLookupBinarySearchHeader = mkStorableArg sfntLookupBinarySearchHeaderStructType

retSFNTLookupBinarySearchHeader :: RetType SFNTLookupBinarySearchHeader
retSFNTLookupBinarySearchHeader = mkStorableRetType sfntLookupBinarySearchHeaderStructType

data STEntryOne = STEntryOne
  { stEntryOneNewState :: !CUShort
  , stEntryOneFlags :: !CUShort
  , stEntryOneOffset1 :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryOne where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = STEntryOne <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (STEntryOne {..}) = do
    pokeByteOff p 0 stEntryOneNewState
    pokeByteOff p 2 stEntryOneFlags
    pokeByteOff p 4 stEntryOneOffset1

{-# NOINLINE stEntryOneStructType #-}
stEntryOneStructType :: Ptr CType
stEntryOneStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTEntryOne :: STEntryOne -> Arg
argSTEntryOne = mkStorableArg stEntryOneStructType

retSTEntryOne :: RetType STEntryOne
retSTEntryOne = mkStorableRetType stEntryOneStructType

data STEntryTwo = STEntryTwo
  { stEntryTwoNewState :: !CUShort
  , stEntryTwoFlags :: !CUShort
  , stEntryTwoOffset1 :: !CUShort
  , stEntryTwoOffset2 :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryTwo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STEntryTwo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STEntryTwo {..}) = do
    pokeByteOff p 0 stEntryTwoNewState
    pokeByteOff p 2 stEntryTwoFlags
    pokeByteOff p 4 stEntryTwoOffset1
    pokeByteOff p 6 stEntryTwoOffset2

{-# NOINLINE stEntryTwoStructType #-}
stEntryTwoStructType :: Ptr CType
stEntryTwoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTEntryTwo :: STEntryTwo -> Arg
argSTEntryTwo = mkStorableArg stEntryTwoStructType

retSTEntryTwo :: RetType STEntryTwo
retSTEntryTwo = mkStorableRetType stEntryTwoStructType

data STEntryZero = STEntryZero
  { stEntryZeroNewState :: !CUShort
  , stEntryZeroFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryZero where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = STEntryZero <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (STEntryZero {..}) = do
    pokeByteOff p 0 stEntryZeroNewState
    pokeByteOff p 2 stEntryZeroFlags

{-# NOINLINE stEntryZeroStructType #-}
stEntryZeroStructType :: Ptr CType
stEntryZeroStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argSTEntryZero :: STEntryZero -> Arg
argSTEntryZero = mkStorableArg stEntryZeroStructType

retSTEntryZero :: RetType STEntryZero
retSTEntryZero = mkStorableRetType stEntryZeroStructType

data STHeader = STHeader
  { stHeaderFiller :: !CUChar
  , stHeaderNClasses :: !CUChar
  , stHeaderClassTableOffset :: !CUShort
  , stHeaderStateArrayOffset :: !CUShort
  , stHeaderEntryTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable STHeader where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STHeader {..}) = do
    pokeByteOff p 0 stHeaderFiller
    pokeByteOff p 1 stHeaderNClasses
    pokeByteOff p 2 stHeaderClassTableOffset
    pokeByteOff p 4 stHeaderStateArrayOffset
    pokeByteOff p 6 stHeaderEntryTableOffset

{-# NOINLINE stHeaderStructType #-}
stHeaderStructType :: Ptr CType
stHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTHeader :: STHeader -> Arg
argSTHeader = mkStorableArg stHeaderStructType

retSTHeader :: RetType STHeader
retSTHeader = mkStorableRetType stHeaderStructType

data STXEntryOne = STXEntryOne
  { stxEntryOneNewState :: !CUShort
  , stxEntryOneFlags :: !CUShort
  , stxEntryOneIndex1 :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryOne where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = STXEntryOne <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (STXEntryOne {..}) = do
    pokeByteOff p 0 stxEntryOneNewState
    pokeByteOff p 2 stxEntryOneFlags
    pokeByteOff p 4 stxEntryOneIndex1

{-# NOINLINE stxEntryOneStructType #-}
stxEntryOneStructType :: Ptr CType
stxEntryOneStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTXEntryOne :: STXEntryOne -> Arg
argSTXEntryOne = mkStorableArg stxEntryOneStructType

retSTXEntryOne :: RetType STXEntryOne
retSTXEntryOne = mkStorableRetType stxEntryOneStructType

data STXEntryTwo = STXEntryTwo
  { stxEntryTwoNewState :: !CUShort
  , stxEntryTwoFlags :: !CUShort
  , stxEntryTwoIndex1 :: !CUShort
  , stxEntryTwoIndex2 :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryTwo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STXEntryTwo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STXEntryTwo {..}) = do
    pokeByteOff p 0 stxEntryTwoNewState
    pokeByteOff p 2 stxEntryTwoFlags
    pokeByteOff p 4 stxEntryTwoIndex1
    pokeByteOff p 6 stxEntryTwoIndex2

{-# NOINLINE stxEntryTwoStructType #-}
stxEntryTwoStructType :: Ptr CType
stxEntryTwoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTXEntryTwo :: STXEntryTwo -> Arg
argSTXEntryTwo = mkStorableArg stxEntryTwoStructType

retSTXEntryTwo :: RetType STXEntryTwo
retSTXEntryTwo = mkStorableRetType stxEntryTwoStructType

data STXEntryZero = STXEntryZero
  { stxEntryZeroNewState :: !CUShort
  , stxEntryZeroFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryZero where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = STXEntryZero <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (STXEntryZero {..}) = do
    pokeByteOff p 0 stxEntryZeroNewState
    pokeByteOff p 2 stxEntryZeroFlags

{-# NOINLINE stxEntryZeroStructType #-}
stxEntryZeroStructType :: Ptr CType
stxEntryZeroStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argSTXEntryZero :: STXEntryZero -> Arg
argSTXEntryZero = mkStorableArg stxEntryZeroStructType

retSTXEntryZero :: RetType STXEntryZero
retSTXEntryZero = mkStorableRetType stxEntryZeroStructType

data STXHeader = STXHeader
  { stxHeaderNClasses :: !CUInt
  , stxHeaderClassTableOffset :: !CUInt
  , stxHeaderStateArrayOffset :: !CUInt
  , stxHeaderEntryTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable STXHeader where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = STXHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (STXHeader {..}) = do
    pokeByteOff p 0 stxHeaderNClasses
    pokeByteOff p 4 stxHeaderClassTableOffset
    pokeByteOff p 8 stxHeaderStateArrayOffset
    pokeByteOff p 12 stxHeaderEntryTableOffset

{-# NOINLINE stxHeaderStructType #-}
stxHeaderStructType :: Ptr CType
stxHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argSTXHeader :: STXHeader -> Arg
argSTXHeader = mkStorableArg stxHeaderStructType

retSTXHeader :: RetType STXHeader
retSTXHeader = mkStorableRetType stxHeaderStructType

data TrakTable = TrakTable
  { trakTableVersion :: !CInt
  , trakTableFormat :: !CUShort
  , trakTableHorizOffset :: !CUShort
  , trakTableVertOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable TrakTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TrakTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (TrakTable {..}) = do
    pokeByteOff p 0 trakTableVersion
    pokeByteOff p 4 trakTableFormat
    pokeByteOff p 6 trakTableHorizOffset
    pokeByteOff p 8 trakTableVertOffset

{-# NOINLINE trakTableStructType #-}
trakTableStructType :: Ptr CType
trakTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argTrakTable :: TrakTable -> Arg
argTrakTable = mkStorableArg trakTableStructType

retTrakTable :: RetType TrakTable
retTrakTable = mkStorableRetType trakTableStructType

data TrakTableEntry = TrakTableEntry
  { trakTableEntryTrack :: !CInt
  , trakTableEntryNameTableIndex :: !CUShort
  , trakTableEntrySizesOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable TrakTableEntry where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = TrakTableEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (TrakTableEntry {..}) = do
    pokeByteOff p 0 trakTableEntryTrack
    pokeByteOff p 4 trakTableEntryNameTableIndex
    pokeByteOff p 6 trakTableEntrySizesOffset

{-# NOINLINE trakTableEntryStructType #-}
trakTableEntryStructType :: Ptr CType
trakTableEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argTrakTableEntry :: TrakTableEntry -> Arg
argTrakTableEntry = mkStorableArg trakTableEntryStructType

retTrakTableEntry :: RetType TrakTableEntry
retTrakTableEntry = mkStorableRetType trakTableEntryStructType

data KernOrderedListEntry = KernOrderedListEntry
  { kernOrderedListEntryPair :: !KernKerningPair
  , kernOrderedListEntryValue :: !CShort
  } deriving (Eq, Show)

instance Storable KernOrderedListEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KernOrderedListEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (KernOrderedListEntry {..}) = do
    pokeByteOff p 0 kernOrderedListEntryPair
    pokeByteOff p 4 kernOrderedListEntryValue

{-# NOINLINE kernOrderedListEntryStructType #-}
kernOrderedListEntryStructType :: Ptr CType
kernOrderedListEntryStructType = unsafePerformIO $ fst <$> newStructCType [kernKerningPairStructType, ffi_type_sint16]

argKernOrderedListEntry :: KernOrderedListEntry -> Arg
argKernOrderedListEntry = mkStorableArg kernOrderedListEntryStructType

retKernOrderedListEntry :: RetType KernOrderedListEntry
retKernOrderedListEntry = mkStorableRetType kernOrderedListEntryStructType

data KerxOrderedListEntry = KerxOrderedListEntry
  { kerxOrderedListEntryPair :: !KerxKerningPair
  , kerxOrderedListEntryValue :: !CShort
  } deriving (Eq, Show)

instance Storable KerxOrderedListEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxOrderedListEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (KerxOrderedListEntry {..}) = do
    pokeByteOff p 0 kerxOrderedListEntryPair
    pokeByteOff p 4 kerxOrderedListEntryValue

{-# NOINLINE kerxOrderedListEntryStructType #-}
kerxOrderedListEntryStructType :: Ptr CType
kerxOrderedListEntryStructType = unsafePerformIO $ fst <$> newStructCType [kerxKerningPairStructType, ffi_type_sint16]

argKerxOrderedListEntry :: KerxOrderedListEntry -> Arg
argKerxOrderedListEntry = mkStorableArg kerxOrderedListEntryStructType

retKerxOrderedListEntry :: RetType KerxOrderedListEntry
retKerxOrderedListEntry = mkStorableRetType kerxOrderedListEntryStructType

data MortContextualSubtable = MortContextualSubtable
  { mortContextualSubtableHeader :: !STHeader
  , mortContextualSubtableSubstitutionTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable MortContextualSubtable where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = MortContextualSubtable <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MortContextualSubtable {..}) = do
    pokeByteOff p 0 mortContextualSubtableHeader
    pokeByteOff p 8 mortContextualSubtableSubstitutionTableOffset

{-# NOINLINE mortContextualSubtableStructType #-}
mortContextualSubtableStructType :: Ptr CType
mortContextualSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType, ffi_type_uint16]

argMortContextualSubtable :: MortContextualSubtable -> Arg
argMortContextualSubtable = mkStorableArg mortContextualSubtableStructType

retMortContextualSubtable :: RetType MortContextualSubtable
retMortContextualSubtable = mkStorableRetType mortContextualSubtableStructType

data MortInsertionSubtable = MortInsertionSubtable
  { mortInsertionSubtableHeader :: !STHeader
  } deriving (Eq, Show)

instance Storable MortInsertionSubtable where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = MortInsertionSubtable <$> peekByteOff p 0
  poke p (MortInsertionSubtable {..}) =
    pokeByteOff p 0 mortInsertionSubtableHeader

{-# NOINLINE mortInsertionSubtableStructType #-}
mortInsertionSubtableStructType :: Ptr CType
mortInsertionSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType]

argMortInsertionSubtable :: MortInsertionSubtable -> Arg
argMortInsertionSubtable = mkStorableArg mortInsertionSubtableStructType

retMortInsertionSubtable :: RetType MortInsertionSubtable
retMortInsertionSubtable = mkStorableRetType mortInsertionSubtableStructType

data MortLigatureSubtable = MortLigatureSubtable
  { mortLigatureSubtableHeader :: !STHeader
  , mortLigatureSubtableLigatureActionTableOffset :: !CUShort
  , mortLigatureSubtableComponentTableOffset :: !CUShort
  , mortLigatureSubtableLigatureTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable MortLigatureSubtable where
  sizeOf    _ = 14
  alignment _ = 2
  peek p = MortLigatureSubtable <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (MortLigatureSubtable {..}) = do
    pokeByteOff p 0 mortLigatureSubtableHeader
    pokeByteOff p 8 mortLigatureSubtableLigatureActionTableOffset
    pokeByteOff p 10 mortLigatureSubtableComponentTableOffset
    pokeByteOff p 12 mortLigatureSubtableLigatureTableOffset

{-# NOINLINE mortLigatureSubtableStructType #-}
mortLigatureSubtableStructType :: Ptr CType
mortLigatureSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argMortLigatureSubtable :: MortLigatureSubtable -> Arg
argMortLigatureSubtable = mkStorableArg mortLigatureSubtableStructType

retMortLigatureSubtable :: RetType MortLigatureSubtable
retMortLigatureSubtable = mkStorableRetType mortLigatureSubtableStructType

data MortRearrangementSubtable = MortRearrangementSubtable
  { mortRearrangementSubtableHeader :: !STHeader
  } deriving (Eq, Show)

instance Storable MortRearrangementSubtable where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = MortRearrangementSubtable <$> peekByteOff p 0
  poke p (MortRearrangementSubtable {..}) =
    pokeByteOff p 0 mortRearrangementSubtableHeader

{-# NOINLINE mortRearrangementSubtableStructType #-}
mortRearrangementSubtableStructType :: Ptr CType
mortRearrangementSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType]

argMortRearrangementSubtable :: MortRearrangementSubtable -> Arg
argMortRearrangementSubtable = mkStorableArg mortRearrangementSubtableStructType

retMortRearrangementSubtable :: RetType MortRearrangementSubtable
retMortRearrangementSubtable = mkStorableRetType mortRearrangementSubtableStructType

data MorxContextualSubtable = MorxContextualSubtable
  { morxContextualSubtableHeader :: !STXHeader
  , morxContextualSubtableSubstitutionTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxContextualSubtable where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = MorxContextualSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (MorxContextualSubtable {..}) = do
    pokeByteOff p 0 morxContextualSubtableHeader
    pokeByteOff p 16 morxContextualSubtableSubstitutionTableOffset

{-# NOINLINE morxContextualSubtableStructType #-}
morxContextualSubtableStructType :: Ptr CType
morxContextualSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint]

argMorxContextualSubtable :: MorxContextualSubtable -> Arg
argMorxContextualSubtable = mkStorableArg morxContextualSubtableStructType

retMorxContextualSubtable :: RetType MorxContextualSubtable
retMorxContextualSubtable = mkStorableRetType morxContextualSubtableStructType

data MorxInsertionSubtable = MorxInsertionSubtable
  { morxInsertionSubtableHeader :: !STXHeader
  , morxInsertionSubtableInsertionGlyphTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxInsertionSubtable where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = MorxInsertionSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (MorxInsertionSubtable {..}) = do
    pokeByteOff p 0 morxInsertionSubtableHeader
    pokeByteOff p 16 morxInsertionSubtableInsertionGlyphTableOffset

{-# NOINLINE morxInsertionSubtableStructType #-}
morxInsertionSubtableStructType :: Ptr CType
morxInsertionSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint]

argMorxInsertionSubtable :: MorxInsertionSubtable -> Arg
argMorxInsertionSubtable = mkStorableArg morxInsertionSubtableStructType

retMorxInsertionSubtable :: RetType MorxInsertionSubtable
retMorxInsertionSubtable = mkStorableRetType morxInsertionSubtableStructType

data MorxLigatureSubtable = MorxLigatureSubtable
  { morxLigatureSubtableHeader :: !STXHeader
  , morxLigatureSubtableLigatureActionTableOffset :: !CUInt
  , morxLigatureSubtableComponentTableOffset :: !CUInt
  , morxLigatureSubtableLigatureTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxLigatureSubtable where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = MorxLigatureSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (MorxLigatureSubtable {..}) = do
    pokeByteOff p 0 morxLigatureSubtableHeader
    pokeByteOff p 16 morxLigatureSubtableLigatureActionTableOffset
    pokeByteOff p 20 morxLigatureSubtableComponentTableOffset
    pokeByteOff p 24 morxLigatureSubtableLigatureTableOffset

{-# NOINLINE morxLigatureSubtableStructType #-}
morxLigatureSubtableStructType :: Ptr CType
morxLigatureSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argMorxLigatureSubtable :: MorxLigatureSubtable -> Arg
argMorxLigatureSubtable = mkStorableArg morxLigatureSubtableStructType

retMorxLigatureSubtable :: RetType MorxLigatureSubtable
retMorxLigatureSubtable = mkStorableRetType morxLigatureSubtableStructType

data MorxRearrangementSubtable = MorxRearrangementSubtable
  { morxRearrangementSubtableHeader :: !STXHeader
  } deriving (Eq, Show)

instance Storable MorxRearrangementSubtable where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = MorxRearrangementSubtable <$> peekByteOff p 0
  poke p (MorxRearrangementSubtable {..}) =
    pokeByteOff p 0 morxRearrangementSubtableHeader

{-# NOINLINE morxRearrangementSubtableStructType #-}
morxRearrangementSubtableStructType :: Ptr CType
morxRearrangementSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType]

argMorxRearrangementSubtable :: MorxRearrangementSubtable -> Arg
argMorxRearrangementSubtable = mkStorableArg morxRearrangementSubtableStructType

retMorxRearrangementSubtable :: RetType MorxRearrangementSubtable
retMorxRearrangementSubtable = mkStorableRetType morxRearrangementSubtableStructType
